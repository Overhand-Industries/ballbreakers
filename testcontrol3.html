<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- The viewport-fit=cover tells supported browsers to use the full display area -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
  <title>ballbreakers – Platformer with Fast-Fall</title>
  <style>
    /* Reset & Full-Screen Setup */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; }
    body { background: #666; font-family: sans-serif; }
    
    /* Scoreboard */
    #scoreboard {
      position: absolute;
      top: 75px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      color: white;
      z-index: 20;
    }
    
    /* Game Shell & Screen */
    #gameboy { position: relative; width: 100vw; height: 100vh; background: #a3c1a3; overflow: hidden; }
    #screen { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; overflow: hidden; }
    /* Parallax Background */
    #parallax { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url('background.png') repeat-x; background-size: auto 100%; z-index: 0; }
    /* Game World Container */
    #game { position: absolute; top: 0; left: 0; z-index: 1; }
    /* Ground */
    #ground { position: absolute; left: 0; background: #0d0c29; }
    
    /* (On-screen controls removed) */
    
    /* In-Game Entity Styling */
    .entity { position: absolute; transform: translate(-50%, -50%); pointer-events: none; transition: transform 0.5s ease, opacity 0.5s ease; }
    /* HP Bar Styling */
    .hp-bar-container { position: absolute; width: 50px; height: 6px; background: rgba(0,0,0,0.5); border: 1px solid #000; border-radius: 3px; pointer-events: none; }
    .hp-bar { width: 100%; height: 100%; background: lime; border-radius: 3px; }
    /* Player Parts (Bubbles) */
    .player-part {
      transform-origin: center; background: #fff; width: 20px; height: 20px; border-radius: 50%;
      box-shadow: 0 0 14px rgba(255,255,255,0.2); position: absolute;
      mask-image: url('mask.png'); mask-size: cover; mask-repeat: no-repeat;
      -webkit-mask-image: url('mask.png'); -webkit-mask-size: cover; -webkit-mask-repeat: no-repeat;
    }
    .player-part::after {
      content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: url('texture.gif') center/cover no-repeat; pointer-events: none; z-index: 10;
      transform-origin: center; animation: spinReverse 2s linear infinite;
    }
    .bullet { background: #fff; border-radius: 50%; }
    .bubble-burst { transform: translate(-50%, -50%) scale(2); opacity: 0; }
    .boulder, .stalactite, .stalagmite { position: absolute; }
    .rock-chunk {
      position: absolute; background: #0d0c29; border: 1px solid #0d0c29; border-radius: 8px;
      clip-path: polygon(10% 0%, 90% 0%, 100% 50%, 90% 100%, 10% 100%, 0% 50%);
    }
    .boulder { transform: translate(-50%, -50%); }
    .head {
      width: 500px; height: 500px; top: 0;
      mask-image: url('overlay2.gif'); mask-repeat: no-repeat; mask-position: center; mask-size: 500px;
      -webkit-mask-image: url('overlay2.gif'); -webkit-mask-size: 500px; -webkit-mask-repeat: no-repeat; -webkit-mask-position: center;
    }
    .head .eye {
      position: absolute; width: 2px; height: 2px; background: red; box-shadow: 0 0 5px red;
    }
    .head .eye.left { left: 30%; top: 30%; }
    .head .eye.right { right: 30%; top: 30%; }
    .enemy { background: black; border: 2px solid black; border-radius: 50%; }
    .goal { position: absolute; background: rgba(0,0,255,0.3); border: 2px dashed #00f; }
    @keyframes flashAnimation { 0% { background-color: rgba(255,255,255,0.8); } 100% { background-color: rgba(255,255,255,0); } }
    .flash { animation: flashAnimation 0.5s ease-out; }
    @keyframes shakeAnimation { 0% { transform: translate(0,0); } 20% { transform: translate(-5px,5px); } 40% { transform: translate(-5px,-5px); } 60% { transform: translate(5px,5px); } 80% { transform: translate(5px,-5px); } 100% { transform: translate(0,0); } }
    .shake { animation: shakeAnimation 0.5s ease; }
    @keyframes goalTextAnimationKeyframes { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(0deg); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(5deg); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1) rotate(-5deg); } }
    .goalTextAnimation { animation: goalTextAnimationKeyframes 1s ease; }
    .tv {
      position: absolute; width: 150px; height: 100px; background: rgba(13,12,41,0.7);
      border: 2px solid rgba(153,153,153,0.8); border-radius: 4px; box-shadow: 0 0 15px rgba(255,255,255,0.2);
      overflow: hidden; animation: tvRandomize 4s infinite alternate;
    }
    .tv::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(circle at top left, rgba(255,255,255,0.5), transparent 60%);
      pointer-events: none;
    }
    .tv::after { content: ""; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
      background: linear-gradient(45deg, rgba(255,255,255,0.2) 25%, rgba(255,255,255,0) 40%, rgba(255,255,255,0.2) 75%);
      transform: rotate(45deg); opacity: 0.5; pointer-events: none; animation: shine 2s infinite;
    }
    @keyframes tvRandomize { 0% { clip-path: polygon(10% 0%, 90% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%); } 25% { clip-path: polygon(15% 5%, 85% 0%, 100% 35%, 85% 100%, 15% 95%, 0% 30%); } 50% { clip-path: polygon(5% 0%, 95% 10%, 100% 45%, 75% 100%, 25% 90%, 0% 35%); } 75% { clip-path: polygon(20% 0%, 80% 0%, 100% 50%, 90% 100%, 10% 100%, 0% 50%); } 100% { clip-path: polygon(10% 0%, 90% 0%, 100% 40%, 80% 100%, 20% 100%, 0% 40%); } }
    @keyframes shine { 0% { transform: translateX(-100%) rotate(45deg); } 50% { transform: translateX(100%) rotate(45deg); } 100% { transform: translateX(-100%) rotate(45deg); } }
    .coin { position: absolute; background: gold; color: black; border-radius: 50%; font-size: 14px; line-height: 20px; text-align: center; box-shadow: 0 0 20px 10px rgba(255,255,200,0.9); }
    .goal-wall { background: #0d0c29; }
    
    /* --- Player-Specific Overrides --- */
    .player-part.player1::after { background: url('overlay5.gif') center/cover no-repeat; }
    .head.player1 { mask-image: url('overlay1.gif'); mask-repeat: no-repeat; mask-position: center; mask-size: 500px; -webkit-mask-image: url('overlay1.gif'); -webkit-mask-size: 500px; -webkit-mask-repeat: no-repeat; -webkit-mask-position: center; }
    .player-part.player2::after { background: url('overlay2.gif') center/cover no-repeat; }
    .head.player2 { mask-image: url('overlay2.gif'); mask-repeat: no-repeat; mask-position: center; mask-size: 500px; -webkit-mask-image: url('overlay2.gif'); -webkit-mask-size: 500px; -webkit-mask-repeat: no-repeat; -webkit-mask-position: center; }
    .enemy-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; background: url('overlay9.gif') center/cover no-repeat; pointer-events: none; }
    .booster-pixel {
      position: absolute; width: 4px; height: 4px;
      background: radial-gradient(circle at center, #FFD700 0%, #FF8C00 50%, transparent 70%);
      image-rendering: pixelated; pointer-events: none; z-index: 20;
      animation: rocketBoost 600ms cubic-bezier(0.2,1,0.3,1) forwards;
    }
    @keyframes rocketBoost {
      0% { transform: translate(0,0) scale(1) rotate(0deg); opacity: 1; filter: drop-shadow(0 0 2px #FF8C00); }
      20% { transform: translate(calc(var(--dx,0)*0.3px), calc(var(--dy,0)*0.3px)) scale(1.1) rotate(calc(var(--rotation,0)*1deg)); opacity: 0.9; filter: drop-shadow(0 0 2px #FFA500); }
      50% { transform: translate(calc(var(--dx,0)*0.7px), calc(var(--dy,0)*0.7px)) scale(0.8) rotate(calc(var(--rotation,0)*1deg)); opacity: 0.6; filter: drop-shadow(0 0 1px #FF4500); }
      100% { transform: translate(calc(var(--dx,0)*1px), calc(var(--dy,0)*1px)) scale(0.5) rotate(calc(var(--rotation,0)*1deg)); opacity: 0; filter: drop-shadow(0 0 1px #FF4500); }
    }
  </style>
</head>
<body>
  <!-- Scoreboard -->
  <div id="scoreboard">
    <span id="leftScore">0</span> - <span id="rightScore">0</span>
  </div>
  
  <div id="gameboy">
    <div id="screen">
      <div id="parallax"></div>
      <div id="game"></div>
    </div>
    <!-- On-screen controls removed -->
  </div>
  
  <!-- Matter.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    /* ================================
       Global Camera & Setup
       ================================ */
    let cameraX = 0, cameraY = 0;
    function updateCamera() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      let points = [ playerChar1.torso.position, playerChar2.torso.position ];
      if (enemies.length > 0) points.push(enemies[0].body.position);
      let sumX = 0, sumY = 0;
      points.forEach(p => { sumX += p.x; sumY += p.y; });
      const centerX = sumX / points.length;
      const centerY = sumY / points.length;
      const margin = 100;
      let minX = Math.min(...points.map(p => p.x)) - margin;
      let maxX = Math.max(...points.map(p => p.x)) + margin;
      let minY = Math.min(...points.map(p => p.y)) - margin;
      let maxY = Math.max(...points.map(p => p.y)) + margin;
      const boxWidth = maxX - minX;
      const boxHeight = maxY - minY;
      const scaleX = screenWidth / boxWidth;
      const scaleY = screenHeight / boxHeight;
      let scale = Math.min(scaleX, scaleY, 1);
      window.currentScale = scale;
      let camX = centerX - screenWidth / (2 * scale);
      let camY = centerY - screenHeight / (2 * scale);
      camX = Math.max(0, Math.min(camX, levelWidth - screenWidth / scale));
      camY = Math.max(0, Math.min(camY, gameHeight - screenHeight / scale));
      cameraX = camX;
      cameraY = camY;
      game.style.transformOrigin = "top left";
      game.style.transform = `translate(-${cameraX}px, -${cameraY}px) scale(${scale})`;
      document.getElementById("parallax").style.backgroundPosition = (-cameraX * 0.5) + "px 0";
    }
    
    /* ================================
       Global Variables & Setup
       ================================ */
    const { Engine, World, Bodies, Body, Constraint, Events, Composites, Composite } = Matter;
    const game = document.getElementById("game");
    let engine = Engine.create();
    engine.world.gravity.y = 3.2;
    const world = engine.world;
    let domEntities = [], platforms = [], walls = [], coins = [], bullets = [], enemies = [];
    let leftScore = 0, rightScore = 0;
    let keys1 = {}, keys2 = {};
    let joystickAim1 = { x: 0, y: 0 }, joystickAim2 = { x: 0, y: 0 };
    let walkCycle1 = 0, walkCycle2 = 0;
    let lastTime = Date.now();
    
    const levelWidth = 1920;
    function getViewportHeight() { return window.visualViewport ? window.visualViewport.height : window.innerHeight; }
    let gameHeight = getViewportHeight();
    let playAreaHeight = getViewportHeight() - 100;
    const groundExtraHeight = 100;
    game.style.width = levelWidth + "px";
    game.style.height = gameHeight + "px";
    
    const groundEl = document.createElement("div");
    groundEl.id = "ground";
    groundEl.style.top = (playAreaHeight - 20) + "px";
    groundEl.style.width = (levelWidth + 40) + "px";
    groundEl.style.height = groundExtraHeight + "px";
    game.appendChild(groundEl);
    
    function createDomElement(body, cls, w, h) {
      const el = document.createElement("div");
      el.className = "entity " + cls;
      el.style.width = w + "px";
      el.style.height = h + "px";
      game.appendChild(el);
      body.domElement = el;
      domEntities.push(body);
    }
    
    /* --- Damage & Break Functions --- */
    function particleBurst(x, y, color) {
      for (let i = 0; i < 10; i++) {
        let particle = document.createElement("div");
        particle.style.position = "absolute";
        particle.style.left = x + "px";
        particle.style.top = y + "px";
        particle.style.width = "4px";
        particle.style.height = "4px";
        particle.style.backgroundColor = color;
        particle.style.borderRadius = "50%";
        particle.style.pointerEvents = "none";
        game.appendChild(particle);
        particle.animate([
          { transform: "translate(0,0)", opacity: 1 },
          { transform: "translate(" + (Math.random()*50 - 25) + "px, " + (Math.random()*50 - 25) + "px)", opacity: 0 }
        ], { duration: 800, easing: "ease-out", fill: "forwards" });
        setTimeout(() => { if (particle.parentNode) particle.parentNode.removeChild(particle); }, 800);
      }
    }
    function breakWall(wall) {
      World.remove(world, wall);
      if (wall.domElement && wall.domElement.parentNode) wall.domElement.parentNode.removeChild(wall.domElement);
      let idx = walls.indexOf(wall);
      if (idx !== -1) walls.splice(idx, 1);
    }
    function breakBoulder(boulder) {
      World.remove(world, boulder);
      if (boulder.domElement && boulder.domElement.parentNode) boulder.domElement.parentNode.removeChild(boulder.domElement);
      let idx = platforms.indexOf(boulder);
      if (idx !== -1) platforms.splice(idx, 1);
    }
    function damageDestructible(obj, damage) {
      if (typeof obj.hp !== "number") return;
      obj.hp -= damage;
      particleBurst(obj.position.x, obj.position.y, "orange");
      if (obj.hp <= 0) {
        particleBurst(obj.position.x, obj.position.y, "red");
        if (obj.label === "wall") breakWall(obj);
        else if (obj.label === "platform") breakBoulder(obj);
        else {
          World.remove(world, obj);
          if (obj.domElement && obj.domElement.parentNode) obj.domElement.parentNode.removeChild(obj.domElement);
          if (obj.label === "enemy") {
            let idx = enemies.findIndex(e => e.body === obj);
            if (idx !== -1) enemies.splice(idx, 1);
          }
        }
      }
    }
    
    /* --- Platforms & Walls --- */
    function createPlatform(x, y, width, height) {
      const slope = Math.random()*0.4+0.3;
      const options = { isStatic: true, label: "platform", density: 0.01 };
      const boulder = Bodies.trapezoid(x+width/2, y+height/2, width, height, slope, options);
      boulder.width = width; boulder.height = height; boulder.hp = 50;
      World.add(world, boulder);
      const el = document.createElement("div");
      el.className = "boulder";
      el.style.width = width+"px";
      el.style.height = height+"px";
      el.style.left = (x+width/2)+"px";
      el.style.top = (y+height/2)+"px";
      el.style.backgroundColor = "#0d0c29";
      const topClipPercent = slope*50;
      el.style.clipPath = `polygon(0% 100%, 100% 100%, ${100-topClipPercent}% 0%, ${topClipPercent}% 0%)`;
      game.appendChild(el);
      boulder.domElement = el;
      platforms.push(boulder);
    }
    function createWall(x, y, width, height) {
      let body, el;
      if (y < playAreaHeight/2) {
        const vertices = [ { x: -width/2, y: 0 }, { x: width/2, y: 0 }, { x: 0, y: height } ];
        body = Bodies.fromVertices(x+width/2, height/3, [vertices], { isStatic:true, label:"wall" }, true);
        body.width = width; body.height = height; body.hp = 100;
        World.add(world, body);
        el = document.createElement("div");
        el.className = "stalactite";
        el.style.width = width+"px";
        el.style.height = height+"px";
        el.style.left = (x+width/2)+"px";
        el.style.top = "0px";
        el.style.backgroundColor = "#0d0c29";
        el.style.clipPath = "polygon(50% 100%, 0% 0%, 100% 0%)";
      } else {
        const vertices = [ { x: -width/2, y: height }, { x: width/2, y: height }, { x: 0, y: 0 } ];
        body = Bodies.fromVertices(x+width/2, playAreaHeight-(2*height)/3, [vertices], { isStatic:true, label:"wall" }, true);
        body.width = width; body.height = height; body.hp = 100;
        World.add(world, body);
        el = document.createElement("div");
        el.className = "stalagmite";
        el.style.width = width+"px";
        el.style.height = height+"px";
        el.style.left = (x+width/2)+"px";
        el.style.top = (playAreaHeight-height)+"px";
        el.style.backgroundColor = "#0d0c29";
        el.style.clipPath = "polygon(50% 0%, 0% 100%, 100% 100%)";
      }
      game.appendChild(el);
      body.domElement = el;
      walls.push(body);
      return body;
    }
    
    // Spawn test platforms & walls
    for (let i = 0; i < 2; i++) {
      const width = Math.floor(Math.random()*101)+200;
      const x = Math.random()*(levelWidth-width);
      const y = 300+Math.random()*(playAreaHeight-350);
      createPlatform(x, y, width, 20);
    }
    for (let i = 0; i < 1; i++) {
      const width = 40;
      const x = Math.random()*(levelWidth-width);
      createWall(x, 100, width, 200);
    }
    
    const groundBody = Bodies.rectangle(levelWidth/2, playAreaHeight, levelWidth+40, 40, { isStatic: true });
    const leftBoundary = Bodies.rectangle(0, playAreaHeight/2, 40, playAreaHeight, { isStatic: true });
    const rightBoundary = Bodies.rectangle(levelWidth, playAreaHeight/2, 40, playAreaHeight, { isStatic: true });
    World.add(world, [groundBody, leftBoundary, rightBoundary]);
    const safetyFloorY = playAreaHeight + 50;
    const safetyFloor = Bodies.rectangle(levelWidth/2, safetyFloorY, levelWidth, 40, { isStatic:true, label:"safetyFloor" });
    World.add(world, safetyFloor);
    
    const goalWidth = 20, goalHeight = 200;
    const leftGoal = Bodies.rectangle(50, playAreaHeight/2, goalWidth, goalHeight, { isStatic:true, isSensor:true, label:"leftGoal" });
    const rightGoal = Bodies.rectangle(levelWidth-50, playAreaHeight/2, goalWidth, goalHeight, { isStatic:true, isSensor:true, label:"rightGoal" });
    World.add(world, [leftGoal, rightGoal]);
    function createGoalDom(goalBody, cls) {
      const el = document.createElement("div");
      el.className = "goal " + cls;
      el.style.width = goalWidth+"px";
      el.style.height = goalHeight+"px";
      el.style.left = (goalBody.position.x-goalWidth/2)+"px";
      el.style.top = (goalBody.position.y-goalHeight/2)+"px";
      game.appendChild(el);
      goalBody.domElement = el;
    }
    createGoalDom(leftGoal, "left");
    createGoalDom(rightGoal, "right");
    
    const wallThickness = 50;
    const fullHeight = playAreaHeight+2;
    const wallCenterY = fullHeight/2;
    const leftGoalWall = Bodies.rectangle(
      leftGoal.position.x - (goalWidth/2 + wallThickness/2 + 20),
      wallCenterY,
      wallThickness,
      fullHeight,
      { isStatic:true, label:"leftGoalWall" }
    );
    const rightGoalWall = Bodies.rectangle(
      rightGoal.position.x + (goalWidth/2 + wallThickness/2 + 20),
      wallCenterY,
      wallThickness,
      fullHeight,
      { isStatic:true, label:"rightGoalWall" }
    );
    World.add(world, [leftGoalWall, rightGoalWall]);
    function createWallDom(wallBody, cls) {
      const el = document.createElement("div");
      el.className = "goal-wall " + cls;
      el.style.width = wallThickness+"px";
      el.style.height = fullHeight+"px";
      el.style.left = (wallBody.position.x - wallThickness/2)+"px";
      el.style.top = (wallBody.position.y - fullHeight/2)+"px";
      el.style.background = "#0d0c29";
      el.style.position = "absolute";
      el.style.zIndex = "15";
      game.appendChild(el);
      wallBody.domElement = el;
    }
    createWallDom(leftGoalWall, "left");
    createWallDom(rightGoalWall, "right");
    
    function createTentacleComposite(x, y, segments, segmentLength, segmentRadius) {
      const tentacle = Composites.stack(x, y, segments, 1, 0, 0, function(x, y) {
        return Bodies.circle(x, y, segmentRadius, { collisionFilter: { group: -1 }, frictionAir: 0.1 });
      });
      Composites.chain(tentacle, 0.5, 0, -0.5, 0, { stiffness: 0.8, length: segmentLength });
      tentacle.bodies.forEach(function(seg) {
        createDomElement(seg, "tentacleSegment", segmentRadius*2, segmentRadius*2);
      });
      return tentacle;
    }
    function attachTentacleToBody(body, anchorOffset, segments, segmentLength, segmentRadius) {
      const startX = body.position.x + anchorOffset.x;
      const startY = body.position.y + anchorOffset.y;
      const tentacle = createTentacleComposite(startX, startY, segments, segmentLength, segmentRadius);
      const constraint = Constraint.create({
        bodyA: body, pointA: anchorOffset,
        bodyB: tentacle.bodies[0], pointB: { x: 0, y: 0 },
        stiffness: 0.8, length: 0
      });
      Composite.add(world, [tentacle, constraint]);
      return tentacle;
    }
    
    function createCharacter(x, y) {
      const char = { hp: 100, alive: true, spawn: { x, y }, heldObject: null, isDying: false };
      char.facing = "right";
      // For jump state and slingshot charge.
      char.jumpReady = true;
      char.jumpCounter = 0; // (Using impulse jump now.)
      char.slingCharge = 0;
      const size = 20;
      const torsoOptions = { friction: 6.0, frictionAir: 0.11, restitution: 0 };
      const defaultOptions = { friction: 0.5, frictionAir: 0.01, restitution: 0 };
      
      const hpContainer = document.createElement("div");
      hpContainer.className = "hp-bar-container";
      const hpBar = document.createElement("div");
      hpBar.className = "hp-bar";
      hpContainer.appendChild(hpBar);
      game.appendChild(hpContainer);
      char.hpContainer = hpContainer;
      char.hpBar = hpBar;
      
      function addPart(body, cls, w, h) {
        createDomElement(body, cls, w, h);
        body.character = char;
        if (cls.indexOf("head") !== -1) {
          attachTentacleToBody(body, { x: 0, y: size/2 }, 5, 10, 2);
          const eyeLeft = document.createElement("div");
          eyeLeft.className = "eye left";
          const eyeRight = document.createElement("div");
          eyeRight.className = "eye right";
          body.domElement.appendChild(eyeLeft);
          body.domElement.appendChild(eyeRight);
        }
        return body;
      }
      
      const head = Bodies.circle(x, y-40, size/2, defaultOptions);
      addPart(head, "player-part head", size, size);
      const torso = Bodies.circle(x, y-20, size, torsoOptions);
      addPart(torso, "player-part torso", size*2, size*2);
      const rightUpperArm = Bodies.circle(x+30, y-20, size/2, defaultOptions);
      addPart(rightUpperArm, "player-part arm", size, size);
      const rightHand = Bodies.circle(x+30, y, size/2, defaultOptions);
      addPart(rightHand, "player-part hand", size, size);
      const leftUpperArm = Bodies.circle(x-30, y-20, size/2, defaultOptions);
      addPart(leftUpperArm, "player-part arm", size, size);
      const leftHand = Bodies.circle(x-30, y, size/2, defaultOptions);
      addPart(leftHand, "player-part hand", size, size);
      const rightUpperLeg = Bodies.circle(x+10, y+10, size/2, defaultOptions);
      addPart(rightUpperLeg, "player-part leg", size, size);
      const rightFoot = Bodies.circle(x+10, y+30, size/2, defaultOptions);
      addPart(rightFoot, "player-part foot", size, size);
      const leftUpperLeg = Bodies.circle(x-10, y+10, size/2, defaultOptions);
      addPart(leftUpperLeg, "player-part leg", size, size);
      const leftFoot = Bodies.circle(x-10, y+30, size/2, defaultOptions);
      addPart(leftFoot, "player-part foot", size, size);
      
      World.add(world, [head, torso, rightUpperArm, rightHand, leftUpperArm, leftHand, rightUpperLeg, rightFoot, leftUpperLeg, leftFoot]);
      
      function link(a, b, offA, offB) {
        const con = Constraint.create({
          bodyA: a, pointA: offA,
          bodyB: b, pointB: offB,
          stiffness: 1, length: 0.1
        });
        World.add(world, con);
      }
      link(head, torso, { x: 0, y: size/2 }, { x: 0, y: -size });
      link(torso, rightUpperArm, { x: size, y: 0 }, { x: 0, y: 0 });
      link(rightUpperArm, rightHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperArm, { x: -size, y: 0 }, { x: 0, y: 0 });
      link(leftUpperArm, leftHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, rightUpperLeg, { x: 10, y: size }, { x: 0, y: -size/2 });
      link(rightUpperLeg, rightFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperLeg, { x: -10, y: size }, { x: 0, y: -size/2 });
      link(leftUpperLeg, leftFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      
      char.head = head; char.torso = torso;
      char.rightUpperArm = rightUpperArm; char.rightHand = rightHand;
      char.leftUpperArm = leftUpperArm; char.leftHand = leftHand;
      char.rightUpperLeg = rightUpperLeg; char.rightFoot = rightFoot;
      char.leftUpperLeg = leftUpperLeg; char.leftFoot = leftFoot;
      
      return char;
    }
    let playerChar1 = createCharacter(100, playAreaHeight/2);
    let playerChar2 = createCharacter(levelWidth-100, playAreaHeight/2);
    function addPlayerClass(player, className) {
      let parts = [player.head, player.torso, player.rightUpperArm, player.rightHand,
                   player.leftUpperArm, player.leftHand, player.rightUpperLeg, player.rightFoot,
                   player.leftUpperLeg, player.leftFoot];
      parts.forEach(part => { if (part.domElement) part.domElement.classList.add(className); });
    }
    addPlayerClass(playerChar1, "player1");
    addPlayerClass(playerChar2, "player2");
    
    function createEnemy(x, y) {
      let enemy = { hp: 50, alive: true, state: "patrol", direction: Math.random()<0.5?-1:1 };
      enemy.body = Bodies.circle(x, y, 20, { friction: 0.5, frictionAir: 0.05, restitution: 1.0, label:"enemy", isBullet:true });
      createDomElement(enemy.body, "enemy", 40, 40);
      World.add(world, enemy.body);
      const overlay = document.createElement("div");
      overlay.classList.add("enemy-overlay");
      enemy.body.domElement.appendChild(overlay);
      enemy.update = function() {
        const dx1 = playerChar1.torso.position.x - enemy.body.position.x;
        const dy1 = playerChar1.torso.position.y - enemy.body.position.y;
        const dist1 = Math.hypot(dx1, dy1);
        const dx2 = playerChar2.torso.position.x - enemy.body.position.x;
        const dy2 = playerChar2.torso.position.y - enemy.body.position.y;
        const dist2 = Math.hypot(dx2, dy2);
        const target = (dist1 < dist2) ? playerChar1 : playerChar2;
        const dx = target.torso.position.x - enemy.body.position.x;
        const dy = target.torso.position.y - enemy.body.position.y;
        const horizontalDistance = Math.abs(dx);
        const verticalDistance = Math.abs(dy);
        const chaseThreshold = 400, verticalThreshold = 50;
        enemy.state = (horizontalDistance < chaseThreshold && verticalDistance < verticalThreshold) ? "chase" : "patrol";
        if (enemy.state === "chase") {
          const chaseForce = 0.001;
          const forceDirection = dx > 0 ? 1 : -1;
          Body.applyForce(enemy.body, enemy.body.position, { x: forceDirection*chaseForce, y: 0 });
          if (dy < -20 && Math.abs(enemy.body.velocity.y) < 1) {
            Body.setVelocity(enemy.body, { x: enemy.body.velocity.x, y: -10 });
          }
        } else {
          const patrolForce = 0.0005;
          Body.applyForce(enemy.body, enemy.body.position, { x: enemy.direction*patrolForce, y: 0 });
          if (enemy.body.position.x < 50) enemy.direction = 1;
          else if (enemy.body.position.x > levelWidth-50) enemy.direction = -1;
        }
      };
      enemies.push(enemy);
      return enemy;
    }
    createEnemy(levelWidth/2, playAreaHeight/2);
    
    /* --- Grab & Throw Functions (for playable character) --- */
// In your grabStart function – if candidate is an enemy, create a constraint:
// Modify the player object to track two hands:
player.leftHeldObject = null;
player.rightHeldObject = null;
player.leftGrabConstraint = null;
player.rightGrabConstraint = null;

// Revised grabStart: decide which hand to use based on candidate position
function grabStart(player, joystickAim) {
  // Only attempt grab if neither hand is busy
  if (!player.leftHeldObject && !player.rightHeldObject) {
    const grabRange = 1000;
    // For grabbing, use the player’s torso center as a reference.
    const torsoPos = player.torso.position;
    let bodies = Composite.allBodies(world);
    let candidate = null, candidateDist = Infinity;
    for (let i = 0; i < bodies.length; i++){
      let body = bodies[i];
      if (body.isStatic || body.character || body.label === "bullet" ||
          body.label === "leftGoal" || body.label === "rightGoal") continue;
      // Distance from candidate to the torso center
      let dx = body.position.x - torsoPos.x;
      let dy = body.position.y - torsoPos.y;
      let dist = Math.hypot(dx, dy);
      if (dist < grabRange && dist < candidateDist) {
        candidate = body;
        candidateDist = dist;
      }
    }
    if (candidate) {
      // Determine which hand should grab based on candidate's x relative to torso
      const useLeft = candidate.position.x < torsoPos.x;
      const hand = useLeft ? player.leftHand : player.rightHand;
      // Save the held object in the corresponding property
      if (useLeft) {
        player.leftHeldObject = candidate;
      } else {
        player.rightHeldObject = candidate;
      }
      // Disable collisions while held
      candidate.collisionFilter.mask = 0;
      // Create a constraint so the enemy “sticks” to the hand.
      // We choose an anchor on the enemy relative to its center.
      const enemyAnchorOffset = { x: useLeft ? -20 : 20, y: 0 };
      const constraint = Constraint.create({
        bodyA: hand,
        pointA: { x: 0, y: 0 },
        bodyB: candidate,
        // The anchor on the enemy is calculated as the offset from its center.
        pointB: enemyAnchorOffset,
        stiffness: 0.9,
        length: 0
      });
      World.add(world, constraint);
      if (useLeft) {
        player.leftGrabConstraint = constraint;
      } else {
        player.rightGrabConstraint = constraint;
      }
    }
  }
}

// Revised grabRelease: release from the hand that holds an object
function grabRelease(player, keys, joystickAim) {
  // Check left hand first
  if (player.leftHeldObject) {
    // Remove constraint if exists
    if (player.leftGrabConstraint) {
      World.remove(world, player.leftGrabConstraint);
      player.leftGrabConstraint = null;
    }
    // Compute throw impulse based on aim
    throwHeldObject(player.leftHeldObject, player, joystickAim);
    player.leftHeldObject = null;
  }
  // Otherwise check right hand
  else if (player.rightHeldObject) {
    if (player.rightGrabConstraint) {
      World.remove(world, player.rightGrabConstraint);
      player.rightGrabConstraint = null;
    }
    throwHeldObject(player.rightHeldObject, player, joystickAim);
    player.rightHeldObject = null;
  }
}

// A helper function to apply a throw impulse to the released object
function throwHeldObject(obj, player, joystickAim) {
  let dx = 0, dy = 0;
  const aimMag = Math.hypot(joystickAim.x, joystickAim.y);
  if (aimMag > 0.1) {
    dx = joystickAim.x; dy = joystickAim.y;
  } else {
    // Fallback: throw in the facing direction if no aim is given
    dx = (player.facing === "left") ? -1 : 1;
    dy = 0;
  }
  const throwSpeed = 55;
  Body.setVelocity(obj, { x: dx * throwSpeed, y: dy * throwSpeed });
  obj.collisionFilter.mask = 0xFFFFFFFF;
}

// Revised updateHeldObject: update position of held objects if not constrained
function updateHeldObject(player, joystickAim) {
  // For left hand
  if (player.leftHeldObject && !player.leftGrabConstraint) {
    const offsetDistance = 40;
    let aimX = joystickAim.x, aimY = joystickAim.y;
    if (Math.hypot(aimX, aimY) < 0.1) { aimX = -1; aimY = 0; }
    const targetX = player.torso.position.x + aimX * offsetDistance;
    const targetY = player.torso.position.y + aimY * offsetDistance;
    Body.setPosition(player.leftHeldObject, { x: targetX, y: targetY });
  }
  // For right hand
  if (player.rightHeldObject && !player.rightGrabConstraint) {
    const offsetDistance = 40;
    let aimX = joystickAim.x, aimY = joystickAim.y;
    if (Math.hypot(aimX, aimY) < 0.1) { aimX = 1; aimY = 0; }
    const targetX = player.torso.position.x + aimX * offsetDistance;
    const targetY = player.torso.position.y + aimY * offsetDistance;
    Body.setPosition(player.rightHeldObject, { x: targetX, y: targetY });
  }
}


    /* --- Melee Attack Function --- */
    function isWithinCone(origin, direction, targetPos, range, angleThreshold) {
      const vector = { x: targetPos.x - origin.x, y: targetPos.y - origin.y };
      const distance = Math.hypot(vector.x, vector.y);
      if (distance > range) return false;
      const targetAngle = Math.atan2(vector.y, vector.x);
      const attackAngle = Math.atan2(direction.y, direction.x);
      let diff = Math.abs(targetAngle - attackAngle);
      if (diff > Math.PI) diff = 2*Math.PI - diff;
      return diff <= angleThreshold;
    }
    function meleeAttack(player, keys, joystickAim) {
      let inputDir = { x: 0, y: 0 };
      if (keys["ArrowLeft"]) inputDir.x -= 1;
      if (keys["ArrowRight"]) inputDir.x += 1;
      if (keys["ArrowUp"]) inputDir.y -= 1;
      if (keys["ArrowDown"]) inputDir.y += 1;
      if (inputDir.x===0 && inputDir.y===0 && Math.hypot(joystickAim.x, joystickAim.y)>0.1) {
        inputDir.x = joystickAim.x; inputDir.y = joystickAim.y;
      }
      if (inputDir.x===0 && inputDir.y===0) inputDir = { x: 0, y: -1 };
      else { const mag = Math.hypot(inputDir.x, inputDir.y); inputDir.x /= mag; inputDir.y /= mag; }
      const attackDir = inputDir;
      const attackHand = (attackDir.x<0) ? player.leftHand : player.rightHand;
      const whipOrigin = (attackDir.x<0) ? player.leftUpperArm.position : player.rightUpperArm.position;
      const option1 = { x: attackDir.y, y: -attackDir.x };
      const option2 = { x: -attackDir.y, y: attackDir.x };
      const tangent = (option1.y<0) ? option1 : option2;
      const maxWhipDistance = 20, swingTime = 300, steps = 15;
      const stepTime = swingTime/steps;
      let step = 0;
      const forceOut = 0.05, forceTangent = 0.05;
      const interval = setInterval(() => {
        const currentDistance = Math.hypot(attackHand.position.x - whipOrigin.x, attackHand.position.y - whipOrigin.y);
        if (currentDistance < maxWhipDistance) {
          const amplitude = Math.sin(Math.PI * step/steps);
          const appliedForce = {
            x: (attackDir.x*forceOut + tangent.x*forceTangent)*amplitude,
            y: (attackDir.y*forceOut + tangent.y*forceTangent)*amplitude
          };
          Body.applyForce(attackHand, attackHand.position, appliedForce);
          Body.applyForce(player.torso, player.torso.position, { x: -appliedForce.x, y: -appliedForce.y });
        }
        step++;
        if (step>=steps) clearInterval(interval);
      }, stepTime);
      setTimeout(() => {
        const attackOrigin = attackHand.position;
        const meleeRange = 60, damageAmount = 30, angleThreshold = Math.PI/6;
        [platforms, walls].forEach(arr => {
          arr.forEach(obj => {
            if (isWithinCone(attackOrigin, attackDir, obj.position, meleeRange, angleThreshold)) {
              damageDestructible(obj, damageAmount);
              triggerScreenshake();
            }
          });
        });
        enemies.forEach(enemy => {
          if (isWithinCone(attackOrigin, attackDir, enemy.body.position, meleeRange, angleThreshold)) {
            triggerScreenshake();
            damageDestructible(enemy.body, damageAmount);
            const knockbackForce = 0.05;
            const dx = enemy.body.position.x - attackOrigin.x;
            const dy = enemy.body.position.y - attackOrigin.y;
            const dist = Math.hypot(dx, dy);
            if (dist>0) {
              Body.applyForce(enemy.body, enemy.body.position, { x: (dx/dist)*knockbackForce, y: (dy/dist)*knockbackForce });
            }
          }
        });
        [playerChar1, playerChar2].forEach(p => {
          if (p!==player && isWithinCone(attackOrigin, attackDir, p.torso.position, meleeRange, angleThreshold)) {
            triggerScreenshake();
            p.hp -= damageAmount;
            const knockbackForce = 0.15;
            const dx = p.torso.position.x - attackOrigin.x;
            const dy = p.torso.position.y - attackOrigin.y;
            const dist = Math.hypot(dx, dy);
            if (dist>0) {
              Body.applyForce(p.torso, p.torso.position, { x: (dx/dist)*knockbackForce, y: (dy/dist)*knockbackForce });
            }
            if (p.hp<=0 && !p.isDying) { p.isDying = true; triggerDeathEffect(); }
          }
        });
      }, 100);
    }
    
    function digitalPixelExplosion(x, y) {
      triggerScreenshake();
      const numPixels = 50;
      for (let i = 0; i < numPixels; i++){
        const pixel = document.createElement("div");
        pixel.style.position = "absolute";
        pixel.style.left = x + "px";
        pixel.style.top = y + "px";
        pixel.style.width = "4px";
        pixel.style.height = "4px";
        pixel.style.background = "#FFF";
        pixel.style.border = "1px solid #000";
        pixel.style.pointerEvents = "none";
        pixel.style.opacity = "1";
        game.appendChild(pixel);
        const angle = Math.random()*2*Math.PI;
        const distance = Math.random()*50+20;
        const deltaX = Math.cos(angle)*distance;
        const deltaY = Math.sin(angle)*distance;
        pixel.animate([
          { transform: "translate(0,0)", opacity: 1 },
          { transform: `translate(${deltaX}px, ${deltaY}px)`, opacity: 0 }
        ], { duration: 1000, easing: "ease-out", fill: "forwards" });
        setTimeout(() => { if (pixel.parentNode) pixel.parentNode.removeChild(pixel); }, 1000);
      }
    }
    
    let coinCount = 0;
    function collectCoin(coin) {
      coinCount++;
      spawnSpark(coin.position.x, coin.position.y);
      World.remove(world, coin);
      coins = coins.filter(c => c !== coin);
      if (coin.domElement && coin.domElement.parentNode) coin.domElement.parentNode.removeChild(coin.domElement);
      console.log("Coin collected! Total:", coinCount);
    }
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        let bullet = null, target = null;
        if (pair.bodyA.label==="bullet") { bullet = pair.bodyA; target = pair.bodyB; }
        else if (pair.bodyB.label==="bullet") { bullet = pair.bodyB; target = pair.bodyA; }
        if (!bullet || !target) return;
        const destructibleLabels = ["platform", "wall", "wallChunk", "enemy"];
        if (destructibleLabels.includes(target.label)) {
          damageDestructible(target, 30);
          if (target.label==="enemy") {
            let dx = target.position.x - bullet.position.x;
            let dy = target.position.y - bullet.position.y;
            let mag = Math.hypot(dx,dy);
            if (mag>0){ dx/=mag; dy/=mag; }
            const knockbackForce = 0.05;
            Body.applyForce(target, target.position, { x: dx*knockbackForce, y: dy*knockbackForce });
          }
        } else if (target.character && target.character !== bullet.owner) {
          damageDestructible(target, 30);
        }
        World.remove(world, bullet);
        if (bullet.domElement && bullet.domElement.parentNode) bullet.domElement.parentNode.removeChild(bullet.domElement);
      });
    });
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if (pair.bodyA.label==="tv" && pair.bodyB.character) { breakTV(pair.bodyA); }
        else if (pair.bodyB.label==="tv" && pair.bodyA.character) { breakTV(pair.bodyB); }
      });
    });
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if (pair.bodyA.label==="coin" && pair.bodyB.character) { collectCoin(pair.bodyA); }
        else if (pair.bodyB.label==="coin" && pair.bodyA.character) { collectCoin(pair.bodyB); }
      });
    });
    function updateScoreboard() {
      document.getElementById("leftScore").textContent = leftScore;
      document.getElementById("rightScore").textContent = rightScore;
    }
    function removeEnemy(enemyBody) {
      World.remove(world, enemyBody);
      if (enemyBody.domElement && enemyBody.domElement.parentNode) {
        enemyBody.domElement.parentNode.removeChild(enemyBody.domElement);
      }
      enemies = enemies.filter(e => e.body !== enemyBody);
    }
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if (pair.bodyA.label==="leftGoal" && pair.bodyB.label==="enemy") {
          leftScore++;
          removeEnemy(pair.bodyB);
          updateScoreboard();
          triggerGoalEffect();
          setTimeout(() => { createEnemy(levelWidth/2, playAreaHeight/2); }, 2000);
        } else if (pair.bodyB.label==="leftGoal" && pair.bodyA.label==="enemy") {
          leftScore++;
          removeEnemy(pair.bodyA);
          updateScoreboard();
          triggerGoalEffect();
          setTimeout(() => { createEnemy(levelWidth/2, playAreaHeight/2); }, 2000);
        } else if (pair.bodyA.label==="rightGoal" && pair.bodyB.label==="enemy") {
          rightScore++;
          removeEnemy(pair.bodyB);
          updateScoreboard();
          triggerGoalEffect();
          setTimeout(() => { createEnemy(levelWidth/2, playAreaHeight/2); }, 2000);
        } else if (pair.bodyB.label==="rightGoal" && pair.bodyA.label==="enemy") {
          rightScore++;
          removeEnemy(pair.bodyA);
          updateScoreboard();
          triggerGoalEffect();
          setTimeout(() => { createEnemy(levelWidth/2, playAreaHeight/2); }, 2000);
        }
      });
    });
    function triggerGoalEffect() {
      let flash = document.getElementById("flashOverlay");
      if (!flash) {
        flash = document.createElement("div");
        flash.id = "flashOverlay";
        flash.style.position = "absolute";
        flash.style.top = "0";
        flash.style.left = "0";
        flash.style.width = "100%";
        flash.style.height = "100%";
        flash.style.zIndex = "50";
        flash.style.pointerEvents = "none";
        game.appendChild(flash);
      }
      flash.classList.remove("flash");
      void flash.offsetWidth;
      flash.classList.add("flash");
      let screenEl = document.getElementById("screen");
      screenEl.classList.remove("shake");
      void screenEl.offsetWidth;
      screenEl.classList.add("shake");
      let goalText = document.createElement("div");
      goalText.id = "goalText";
      goalText.innerText = "GOAL!";
      goalText.style.position = "absolute";
      goalText.style.top = "50%";
      goalText.style.left = "50%";
      goalText.style.transform = "translate(-50%, -50%)";
      goalText.style.fontSize = "72px";
      goalText.style.fontWeight = "bold";
      goalText.style.fontFamily = '"Impact", "Arial Black", sans-serif';
      goalText.style.color = "white";
      goalText.style.zIndex = "60";
      goalText.style.pointerEvents = "none";
      game.appendChild(goalText);
      goalText.classList.add("goalTextAnimation");
      setTimeout(() => { if (goalText.parentNode) goalText.parentNode.removeChild(goalText); }, 1000);
    }
    function triggerScreenshake() {
      const screenEl = document.getElementById("screen");
      screenEl.classList.remove("shake");
      void screenEl.offsetWidth;
      screenEl.classList.add("shake");
    }
    function triggerOutEffect() {
      const outText = document.createElement("div");
      outText.id = "outText";
      outText.innerText = "OUT!";
      outText.style.position = "absolute";
      outText.style.top = "50%";
      outText.style.left = "50%";
      outText.style.transform = "translate(-50%, -50%)";
      outText.style.fontSize = "72px";
      outText.style.fontWeight = "bold";
      outText.style.fontFamily = '"Impact", "Arial Black", sans-serif';
      outText.style.color = "red";
      outText.style.zIndex = "60";
      outText.style.pointerEvents = "none";
      game.appendChild(outText);
      const screenEl = document.getElementById("screen");
      screenEl.classList.remove("shake");
      void screenEl.offsetWidth;
      screenEl.classList.add("shake");
      outText.classList.add("goalTextAnimation");
      setTimeout(() => { if (outText.parentNode) outText.parentNode.removeChild(outText); }, 1000);
    }
    function checkEnemyOutOfBounds() {
      enemies.slice().forEach(enemy => {
        const pos = enemy.body.position;
        const outHorizontally = pos.x < 0 || pos.x > levelWidth;
        const outBelowSafety = pos.y > safetyFloorY;
        const groundCenter = (playAreaHeight-20)+(groundExtraHeight/2);
        const groundPenetration = pos.y > groundCenter && enemy.body.speed > 3;
        if (outHorizontally || outBelowSafety || groundPenetration) {
          triggerOutEffect();
          removeEnemy(enemy.body);
          setTimeout(() => { createEnemy(levelWidth/2, playAreaHeight/2); }, 2000);
        }
      });
    }
    function respawnPlayer(player) {
      const parts = [player.head, player.torso, player.rightUpperArm, player.rightHand,
                     player.leftUpperArm, player.leftHand, player.rightUpperLeg, player.rightFoot,
                     player.leftUpperLeg, player.leftFoot];
      parts.forEach(part => {
        World.remove(world, part);
        if (part.domElement && part.domElement.parentNode) part.domElement.parentNode.removeChild(part.domElement);
      });
      if (player.hpContainer && player.hpContainer.parentNode) {
        player.hpContainer.parentNode.removeChild(player.hpContainer);
      }
    }
    function createRocketBoosterEffect(player) {
      const offsetX = player.facing==="right" ? -15 : 15;
      const origin = { x: player.torso.position.x + offsetX, y: player.torso.position.y };
      const numPixels = 12;
      for (let i=0; i<numPixels; i++){
        const pixel = document.createElement("div");
        pixel.className = "booster-pixel";
        pixel.style.left = origin.x + "px";
        pixel.style.top = origin.y + "px";
        const dx = Math.random()*20 - 10;
        const dy = Math.random()*20;
        pixel.style.setProperty("--dx", dx);
        pixel.style.setProperty("--dy", dy);
        pixel.style.setProperty("--rotation", Math.random()*360);
        game.appendChild(pixel);
        setTimeout(() => pixel.remove(), 600);
      }
    }
    
    /* ================================
       Main Update Loop
       ================================ */
    function update() {
      const now = Date.now();
      let dt = (now - lastTime)/1000;
      lastTime = now;
      
      updateGamepadInput();
      Engine.update(engine, 1000/60);
      engine.positionIterations = 10;
      engine.velocityIterations = 10;
      engine.constraintIterations = 4;
      
      // --- Player One Movement, Jump, & Slingshot/Fast-Fall ---
      if (keys1["ArrowLeft"]) {
        playerChar1.facing = "left";
        Body.applyForce(playerChar1.torso, playerChar1.torso.position, { x: -0.01, y: 0 });
      }
      if (keys1["ArrowRight"]) {
        playerChar1.facing = "right";
        Body.applyForce(playerChar1.torso, playerChar1.torso.position, { x: 0.01, y: 0 });
      }
      // Jump: Apply a single impulse when Up (or W) is pressed and on ground.
      if ((keys1["ArrowUp"] || keys1["KeyW"]) && playerChar1.jumpReady && playerChar1.torso.position.y >= playAreaHeight-60) {
        const jumpImpulse = 0.3; // adjust as desired
        Body.applyForce(playerChar1.torso, playerChar1.torso.position, { x: 0, y: -jumpImpulse });
        playerChar1.jumpReady = false;
      }
      if (!(keys1["ArrowUp"] || keys1["KeyW"]) && playerChar1.torso.position.y >= playAreaHeight-60) {
        playerChar1.jumpReady = true;
      }
      // Slingshot / Fast-Fall for Player 1:
      if (keys1["ArrowDown"] || keys1["KeyS"]) {
        // If airborne, apply fast-fall force.
        if (playerChar1.torso.position.y < playAreaHeight-60) {
          const fastFallForce = 0.02; // Adjust to force the character down quicker
          Body.applyForce(playerChar1.torso, playerChar1.torso.position, { x: 0, y: fastFallForce });
        } else {
          // Otherwise (on ground), charge a slingshot impulse.
          playerChar1.slingCharge = (playerChar1.slingCharge || 0) + dt;
          const maxSlingCharge = 2.0;
          if (playerChar1.slingCharge > maxSlingCharge) playerChar1.slingCharge = maxSlingCharge;
        }
      }
      
      // --- Player Two Movement & Jump ---
      if (keys2["ArrowLeft"]) {
        playerChar2.facing = "left";
        Body.applyForce(playerChar2.torso, playerChar2.torso.position, { x: -0.01, y: 0 });
      }
      if (keys2["ArrowRight"]) {
        playerChar2.facing = "right";
        Body.applyForce(playerChar2.torso, playerChar2.torso.position, { x: 0.01, y: 0 });
      }
      if ((keys2["ArrowUp"] || keys2["KeyW"]) && playerChar2.jumpReady && playerChar2.torso.position.y >= playAreaHeight-60) {
        const jumpImpulse = 0.3;
        Body.applyForce(playerChar2.torso, playerChar2.torso.position, { x: 0, y: -jumpImpulse });
        playerChar2.jumpReady = false;
      }
      if (!(keys2["ArrowUp"] || keys2["KeyW"]) && playerChar2.torso.position.y >= playAreaHeight-60) {
        playerChar2.jumpReady = true;
      }
      
      // --- Air Steering (only if not charging slingshot on P1) ---
      if (playerChar1.torso.position.y < playAreaHeight-30 && !(keys1["ArrowDown"] || keys1["KeyS"])) {
        let airInput = { x: 0, y: 0 };
        if (keys1["ArrowLeft"]) airInput.x -= 1;
        if (keys1["ArrowRight"]) airInput.x += 1;
        if (keys1["ArrowUp"]) airInput.y -= 1;
        let mag = Math.hypot(airInput.x, airInput.y);
        if (mag>0) {
          airInput.x /= mag; airInput.y /= mag;
          const airControlForce = 0.002;
          Body.applyForce(playerChar1.torso, playerChar1.torso.position, { x: airInput.x*airControlForce, y: airInput.y*airControlForce });
        }
      }
      if (playerChar2.torso.position.y < playAreaHeight-30 && !(keys2["ArrowDown"] || keys2["KeyS"])) {
        let airInput = { x: 0, y: 0 };
        if (keys2["ArrowLeft"]) airInput.x -= 1;
        if (keys2["ArrowRight"]) airInput.x += 1;
        if (keys2["ArrowUp"]) airInput.y -= 1;
        let mag = Math.hypot(airInput.x, airInput.y);
        if (mag>0) {
          airInput.x /= mag; airInput.y /= mag;
          const airControlForce = 0.002;
          Body.applyForce(playerChar2.torso, playerChar2.torso.position, { x: airInput.x*airControlForce, y: airInput.y*airControlForce });
        }
      }
      
      // --- Update DOM Positions ---
      domEntities.forEach(body => {
        if (body.domElement) {
          body.domElement.style.left = body.position.x + "px";
          body.domElement.style.top = body.position.y + "px";
          body.domElement.style.transform = "translate(-50%, -50%) rotate(" + body.angle + "rad)";
        }
      });
      coins.forEach(coin => {
        if (coin.domElement) {
          coin.domElement.style.left = coin.position.x + "px";
          coin.domElement.style.top = coin.position.y + "px";
        }
      });
      enemies.forEach(enemy => {
        enemy.update();
        if (enemy.body.domElement) {
          enemy.body.domElement.style.left = enemy.body.position.x + "px";
          enemy.body.domElement.style.top = enemy.body.position.y + "px";
          enemy.body.domElement.style.transform = "translate(-50%, -50%) rotate(" + enemy.body.angle + "rad)";
        }
      });
      
      updateHeldObject(playerChar1, joystickAim1);
      updateHeldObject(playerChar2, joystickAim2);
      
      // Sync head to torso.
      Body.setPosition(playerChar1.head, { x: playerChar1.torso.position.x, y: playerChar1.torso.position.y - 40 });
      Body.setVelocity(playerChar1.head, playerChar1.torso.velocity);
      Body.setPosition(playerChar2.head, { x: playerChar2.torso.position.x, y: playerChar2.torso.position.y - 40 });
      Body.setVelocity(playerChar2.head, playerChar2.torso.velocity);
      
      // (Clamping players, walking animations, and HP bar updates omitted for brevity.)
      
      checkEnemyOutOfBounds();
      updateCamera();
      requestAnimationFrame(update);
    }
    update();
    
    /* ================================
       Gamepad Support
       ================================ */
    let lastGamepadButtonState = {};
    window.addEventListener("gamepadconnected", e => { console.log("Gamepad connected:", e.gamepad); });
    window.addEventListener("gamepaddisconnected", e => { console.log("Gamepad disconnected:", e.gamepad); delete lastGamepadButtonState[e.gamepad.index]; });
    function updateGamepadInput() {
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      const threshold = 0.2;
      for (let i=0; i<gamepads.length; i++){
        const gp = gamepads[i];
        if (!gp) continue;
        if (gp.index === 0) {
          if (gp.axes[0] < -threshold) { keys1["ArrowLeft"] = true; keys1["ArrowRight"] = false; }
          else if (gp.axes[0] > threshold) { keys1["ArrowRight"] = true; keys1["ArrowLeft"] = false; }
          else { keys1["ArrowLeft"] = keys1["ArrowRight"] = false; }
          keys1["ArrowUp"] = false; // Jump via keyboard for now.
          // Button 7 for grab/throw.
          const grabPressed = gp.buttons[7].pressed;
          const wasGrabPressed = lastGamepadButtonState[gp.index] ? lastGamepadButtonState[gp.index][7] : false;
          if (grabPressed && !wasGrabPressed) { grabStart(playerChar1, joystickAim1); }
          else if (!grabPressed && wasGrabPressed) { grabRelease(playerChar1, keys1, joystickAim1); }
          let rx = gp.axes[2], ry = gp.axes[3];
          let rmag = Math.hypot(rx, ry);
          if (rmag > threshold) { joystickAim1.x = rx/rmag; joystickAim1.y = ry/rmag; }
          else { joystickAim1.x = joystickAim1.y = 0; }
          if (!lastGamepadButtonState[gp.index]) lastGamepadButtonState[gp.index] = new Array(gp.buttons.length).fill(false);
          const meleePressed = (gp.buttons[2].pressed || gp.buttons[6].pressed);
          const meleeWasPressed = (lastGamepadButtonState[gp.index][2] || lastGamepadButtonState[gp.index][6]);
          if (meleePressed && !meleeWasPressed) { meleeAttack(playerChar1, keys1, joystickAim1); }
          lastGamepadButtonState[gp.index] = gp.buttons.map(b => b.pressed);
        } else if (gp.index === 1) {
          if (gp.axes[0] < -threshold) { keys2["ArrowLeft"] = true; keys2["ArrowRight"] = false; }
          else if (gp.axes[0] > threshold) { keys2["ArrowRight"] = true; keys2["ArrowLeft"] = false; }
          else { keys2["ArrowLeft"] = keys2["ArrowRight"] = false; }
          keys2["ArrowUp"] = false;
          keys2["Space"] = (gp.buttons[0].pressed || gp.buttons[11].pressed);
          let rx = gp.axes[2], ry = gp.axes[3];
          let rmag = Math.hypot(rx, ry);
          if (rmag > threshold) { joystickAim2.x = rx/rmag; joystickAim2.y = ry/rmag; }
          else { joystickAim2.x = joystickAim2.y = 0; }
          if (!lastGamepadButtonState[gp.index]) lastGamepadButtonState[gp.index] = new Array(gp.buttons.length).fill(false);
          const meleePressed2 = (gp.buttons[2].pressed || gp.buttons[6].pressed);
          const meleeWasPressed2 = (lastGamepadButtonState[gp.index][2] || lastGamepadButtonState[gp.index][6]);
          if (meleePressed2 && !meleeWasPressed2) { meleeAttack(playerChar2, keys2, joystickAim2); }
          lastGamepadButtonState[gp.index] = gp.buttons.map(b => b.pressed);
        }
      }
    }
    
    /* ================================
       Keyboard & Mouse Controls
       ================================ */
    document.addEventListener('keydown', e => {
      const key = e.code;
      if (key==='ArrowUp' || key==='KeyW') { keys1["ArrowUp"] = true; }
      if (key==='ArrowLeft' || key==='KeyA') { keys1["ArrowLeft"] = true; }
      if (key==='ArrowRight' || key==='KeyD') { keys1["ArrowRight"] = true; }
      if (key==='ArrowDown' || key==='KeyS') { keys1["ArrowDown"] = true; }
      // Spacebar triggers melee attack.
      if (key===' ') { meleeAttack(playerChar1, keys1, joystickAim1); }
    });
    document.addEventListener('keyup', e => {
      const key = e.code;
      if (key==='ArrowUp' || key==='KeyW') { keys1["ArrowUp"] = false; }
      if (key==='ArrowLeft' || key==='KeyA') { keys1["ArrowLeft"] = false; }
      if (key==='ArrowRight' || key==='KeyD') { keys1["ArrowRight"] = false; }
      if (key==='ArrowDown' || key==='KeyS') {
        // On keyup, if on ground and charge exists, fire slingshot impulse.
        if (playerChar1.torso.position.y >= playAreaHeight-60 && playerChar1.slingCharge && playerChar1.slingCharge > 0) {
          const baseSlingForce = 0.05;
          const forceMagnitude = playerChar1.slingCharge * baseSlingForce;
          let aim = { x: joystickAim1.x, y: joystickAim1.y };
          if (Math.hypot(aim.x, aim.y) < 0.1) { aim.x = 0; aim.y = -1; }
          Body.applyForce(playerChar1.torso, playerChar1.torso.position, { x: aim.x * forceMagnitude, y: aim.y * forceMagnitude });
          playerChar1.slingCharge = 0;
        }
        keys1["ArrowDown"] = false;
      }
    });
    // Mouse: Left-click for grab/hold.
    document.addEventListener('mousedown', e => { if(e.button===0) { grabStart(playerChar1, joystickAim1); } });
    document.addEventListener('mouseup', e => { if(e.button===0) { grabRelease(playerChar1, keys1, joystickAim1); } });
    document.addEventListener('mousemove', e => {
      const rect = game.getBoundingClientRect();
      const scale = window.currentScale || 1;
      const mouseX = (e.clientX - rect.left)/scale + cameraX;
      const mouseY = (e.clientY - rect.top)/scale + cameraY;
      const dx = mouseX - playerChar1.torso.position.x;
      const dy = mouseY - playerChar1.torso.position.y;
      const mag = Math.hypot(dx, dy);
      if (mag > 0) { joystickAim1.x = dx/mag; joystickAim1.y = dy/mag; }
      else { joystickAim1.x = joystickAim1.y = 0; }
    });
    
    /* ================================
       Auto-scroll (Optional)
       ================================ */
    window.addEventListener("load", () => { window.scrollTo(0, document.body.scrollHeight); });
    window.addEventListener("scroll", () => {
      const maxScroll = document.body.scrollHeight - window.innerHeight;
      if (window.scrollY < maxScroll) window.scrollTo(0, maxScroll);
    });
  </script>
</body>
</html>
