<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Skies of Arcadia Airship Simulator</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #instructions {
      position: fixed;
      left: 10px;
      top: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      max-width: 250px;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/S: Move forward/backward</p>
    <p>A/D: Turn left/right</p>
    <p>Q/E: Strafe left/right</p>
    <p>Space: Ascend (can be used while moving)</p>
    <p>Shift: Descend (can be used while moving)</p>
    <p>F: Toggle camera view</p>
    <p>Left Click: Fire cannons (works in all camera modes)</p>
    <p><small>Check the console (F12) for loading messages</small></p>
  </div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    
    // Main Game Class: AirshipGame
    class AirshipGame {
      constructor() {
        console.log("Initializing Airship Simulator...");

        // Scene setup with fog
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87CEEB);
        // Apply fog: objects start fading at 100 units and are fully obscured at 1500 units.
        this.scene.fog = new THREE.Fog(0x87CEEB, 100, 1500);
        
        // Camera setup
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.position.set(0, 5, -10);
        this.camera.lookAt(0, 0, 0);
        
        // Renderer setup
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 100, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        this.scene.add(directionalLight);
        
        // Initialize game variables
        this.keys = {};
        this.velocity = new THREE.Vector3();
        this.rotation = new THREE.Vector3();
        this.clock = new THREE.Clock();
        this.projectiles = [];
        this.cannonCooldown = 0;
        this.cannonCooldownTime = 20;
        this.targetPoint = new THREE.Vector3();
        this.canFireCannons = false;
        this.antigravActive = true;
        this.hoverHeight = 50;
        this.enginePower = 0.08;
        this.verticalSpeed = 0.5;
        this.windEffect = 0.0005;
        this.bankingFactor = 0.05;
        this.turnInertia = 0.85;
        this.lateralDrag = 0.98;
        this.verticalDrag = 0.96;
        this.verticalDampening = 0.92;
        this.hardDeckLimit = 5;
        this.minAltitude = 10;
        this.maxAltitude = 200;
        this.engineSoundEnabled = false;
        this.engineSoundIntensity = 0;
        
        // Camera mode variables
        this.cameraMode = 'follow'; // 'follow', 'orbit', or 'overhead'
        this.orbitDistance = 15;
        this.orbitHeight = 5;
        this.orbitAngleHorizontal = 0;
        this.orbitAngleVertical = 0;
        this.isMouseDown = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.mouseSensitivity = 0.005;
        
        // Create game elements
        this.createSkybox();
        this.createClouds();
        this.createAirship();
        this.createEnemyAirship(); // Enemy airship (placeholder logic)
        console.log("Creating terrain...");
        this.createLIDARTerrain();
        console.log("Adding grass...");
        this.createGrassGround();
        console.log("Terrain created!");
        
        // Position the airship for a better view of the terrain
        this.airship.position.set(0, 50, 0);
        
        // Input management
        window.addEventListener('keydown', (e) => {
          this.keys[e.key.toLowerCase()] = true;
          if (e.key.toLowerCase() === 'f') {
            if (this.cameraMode === 'follow') {
              this.cameraMode = 'orbit';
              const toCamera = new THREE.Vector3().subVectors(this.camera.position, this.airship.position);
              this.orbitAngleHorizontal = Math.atan2(toCamera.x, toCamera.z);
              this.orbitAngleVertical = Math.asin(toCamera.y / toCamera.length());
              this.orbitDistance = toCamera.length();
              console.log("Camera mode: Orbit (Use mouse to look around)");
            } else if (this.cameraMode === 'orbit') {
              this.cameraMode = 'overhead';
              console.log("Camera mode: Overhead");
            } else {
              this.cameraMode = 'follow';
              const behindShip = new THREE.Vector3(0, 5, -15);
              behindShip.applyQuaternion(this.airship.quaternion);
              this.camera.position.copy(this.airship.position).add(behindShip);
              this.camera.lookAt(this.airship.position);
              console.log("Camera mode: Follow");
            }
          }
        });
        window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('resize', () => this.handleResize());
        
        // Mouse and click events
        window.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        window.addEventListener('mouseup', () => this.handleMouseUp());
        window.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        window.addEventListener('wheel', (e) => this.handleMouseWheel(e));
        window.addEventListener('click', () => this.fireCannons());
        window.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Additional UI elements
        this.createLockIndicator();
        this.createCrosshair();
        
        // Start the animation loop
        this.animate();
        console.log("Airship Simulator ready! Use WASD to move, Space/Shift for up/down, F to toggle camera.");
      }
      
      // Create a skybox for the scene
      createSkybox() {
        const skyGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const skyMaterial = new THREE.MeshBasicMaterial({
          color: 0x87ceeb,
          side: THREE.BackSide,
        });
        const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
        this.scene.add(skybox);
      }
      
      // Create clouds (both billboard and fog clouds)
      createClouds() {
        this.clouds = new THREE.Group();
        this.scene.add(this.clouds);
        const numBillboardClouds = 8;
        for (let layer = 0; layer < 4; layer++) {
          for (let i = 0; i < numBillboardClouds; i++) {
            const cloud = this.createBillboardCloud(layer);
            const radius = 400 + Math.random() * 200;
            const angle = (i / numBillboardClouds) * Math.PI * 2 + Math.random() * 0.5;
            cloud.position.set(
              Math.cos(angle) * radius,
              40 + layer * 30 + Math.random() * 20,
              Math.sin(angle) * radius
            );
            cloud.lookAt(0, cloud.position.y, 0);
            cloud.userData = {
              type: 'billboard',
              angle: angle,
              radius: radius,
              speed: 0.0005 + Math.random() * 0.0005,
              timeOffset: Math.random() * Math.PI * 2
            };
            this.clouds.add(cloud);
          }
        }
        const numFogClouds = 12;
        for (let i = 0; i < numFogClouds; i++) {
          const cloud = this.createFogCloud();
          const radius = 150 + Math.random() * 150;
          const angle = Math.random() * Math.PI * 2;
          cloud.position.set(
            Math.cos(angle) * radius,
            30 + Math.random() * 40,
            Math.sin(angle) * radius
          );
          cloud.userData = {
            type: 'fog',
            originalY: cloud.position.y,
            timeOffset: Math.random() * Math.PI * 2
          };
          this.clouds.add(cloud);
        }
      }
      
      // Create a billboard cloud from overlapping planes
      createBillboardCloud(layer) {
        const group = new THREE.Group();
        const textureLoader = new THREE.TextureLoader();
        const cloudTextures = [
          'https://mrdoob.com/lab/javascript/webgl/clouds/cloud10.png',
          'https://mrdoob.com/lab/javascript/webgl/clouds/cloud11.png',
          'https://mrdoob.com/lab/javascript/webgl/clouds/cloud12.png',
          'https://mrdoob.com/lab/javascript/webgl/clouds/cloud13.png',
          'https://mrdoob.com/lab/javascript/webgl/clouds/cloud14.png',
          'https://mrdoob.com/lab/javascript/webgl/clouds/cloud15.png'
        ];
        const numPlanes = 3 + Math.floor(Math.random() * 2);
        for (let i = 0; i < numPlanes; i++) {
          const texture = textureLoader.load(cloudTextures[Math.floor(Math.random() * cloudTextures.length)]);
          const size = 30 + Math.random() * 20;
          const geometry = new THREE.PlaneGeometry(size, size);
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: 0.7 - (layer * 0.1),
            depthWrite: false,
            depthTest: true,
            alphaTest: 0.2
          });
          const plane = new THREE.Mesh(geometry, material);
          plane.position.set(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 3
          );
          group.add(plane);
        }
        return group;
      }
      
      // Create a fog cloud composed of many particles
      createFogCloud() {
        const group = new THREE.Group();
        const numParticles = 20 + Math.floor(Math.random() * 10);
        for (let i = 0; i < numParticles; i++) {
          const size = 15 + Math.random() * 10;
          const geometry = new THREE.PlaneGeometry(size, size);
          const material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            depthWrite: false,
            depthTest: true,
            alphaTest: 0.1
          });
          const particle = new THREE.Mesh(geometry, material);
          const radius = 10 + Math.random() * 8;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          particle.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.cos(phi) * 0.3,
            radius * Math.sin(phi) * Math.sin(theta)
          );
          particle.userData = {
            originalPos: particle.position.clone(),
            speed: 0.0002 + Math.random() * 0.0002,
            offset: Math.random() * Math.PI * 2
          };
          group.add(particle);
        }
        return group;
      }
      
      // Create the player's airship
      createAirship() {
        this.airship = new THREE.Group();
        this.airship.rotation.y = 0;
        this.scene.add(this.airship);
        
        // Ship hull with rounded bottom and tapered bow/stern
        const hullGeometry = new THREE.BoxGeometry(5, 1.5, 12);
        const hullPositions = hullGeometry.attributes.position.array;
        for (let i = 0; i < hullPositions.length; i += 3) {
          if (hullPositions[i + 1] < 0) {
            const xPos = hullPositions[i];
            const roundingFactor = 0.2 * (Math.abs(xPos) / 2.5);
            hullPositions[i + 1] -= roundingFactor;
            const zPos = hullPositions[i + 2];
            const taperZ = 0.3 * (Math.abs(zPos) / 6.0);
            hullPositions[i] *= (1.0 - taperZ);
          }
        }
        hullGeometry.computeVertexNormals();
        const hullMaterial = new THREE.MeshPhongMaterial({
          color: 0x8B4513,
          flatShading: false,
          shininess: 10
        });
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
        hull.castShadow = true;
        hull.receiveShadow = true;
        
        // Deck
        const deckGeometry = new THREE.BoxGeometry(4.8, 0.2, 11.8);
        const deckMaterial = new THREE.MeshPhongMaterial({
          color: 0xA0522D,
          flatShading: false
        });
        const deck = new THREE.Mesh(deckGeometry, deckMaterial);
        deck.position.y = 0.85;
        deck.castShadow = true;
        deck.receiveShadow = true;
        
        // Mast and sails
        const mastGeometry = new THREE.CylinderGeometry(0.2, 0.3, 8, 8);
        const mastMaterial = new THREE.MeshPhongMaterial({
          color: 0x8B4513,
          flatShading: false
        });
        const mast = new THREE.Mesh(mastGeometry, mastMaterial);
        mast.position.set(0, 5, -1);
        mast.castShadow = true;
        const sailGeometry = new THREE.PlaneGeometry(3, 4);
        const sailMaterial = new THREE.MeshPhongMaterial({
          color: 0xFFFFFF,
          side: THREE.DoubleSide,
          flatShading: false,
        });
        const mainSail = new THREE.Mesh(sailGeometry, sailMaterial);
        mainSail.rotation.y = Math.PI / 2;
        mainSail.position.set(0, 4, -1);
        mainSail.castShadow = true;
        const frontSail = new THREE.Mesh(
          new THREE.PlaneGeometry(2, 3),
          sailMaterial.clone()
        );
        frontSail.rotation.y = Math.PI / 2;
        frontSail.position.set(0, 3, 3);
        frontSail.castShadow = true;
        
        // Flag and decorative elements
        const flagPoleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
        const flagPole = new THREE.Mesh(flagPoleGeometry, mastMaterial.clone());
        flagPole.position.set(0, 9, -1);
        const flagGeometry = new THREE.PlaneGeometry(1, 0.6);
        const flagMaterial = new THREE.MeshPhongMaterial({
          color: 0x000000,
          side: THREE.DoubleSide
        });
        const flag = new THREE.Mesh(flagGeometry, flagMaterial);
        flag.rotation.y = Math.PI / 2;
        flag.position.set(0, 0.8, 0);
        flagPole.add(flag);
        const skullGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const skullMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const skull = new THREE.Mesh(skullGeometry, skullMaterial);
        skull.position.set(0.06, 0, 0);
        flag.add(skull);
        
        // Engines with glow effect
        const engineCount = 2;
        const engines = [];
        for (let i = 0; i < engineCount; i++) {
          const engineGroup = new THREE.Group();
          const engineHousingGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2, 8);
          const engineHousingMaterial = new THREE.MeshPhongMaterial({
            color: 0x444444,
            metalness: 0.8,
            roughness: 0.2
          });
          const engineHousing = new THREE.Mesh(engineHousingGeometry, engineHousingMaterial);
          engineHousing.rotation.x = Math.PI / 2;
          engineGroup.add(engineHousing);
          const nozzleGeometry = new THREE.CylinderGeometry(0.5, 0.3, 0.8, 8);
          const nozzleMaterial = new THREE.MeshPhongMaterial({
            color: 0x333333,
            metalness: 0.9,
            roughness: 0.1
          });
          const nozzle = new THREE.Mesh(nozzleGeometry, nozzleMaterial);
          nozzle.position.z = -1.4;
          nozzle.rotation.x = Math.PI / 2;
          engineGroup.add(nozzle);
          const glowGeometry = new THREE.CylinderGeometry(0.2, 0.4, 0.5, 8);
          const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xFF4500,
            transparent: true,
            opacity: 0.8
          });
          const engineGlow = new THREE.Mesh(glowGeometry, glowMaterial);
          engineGlow.position.z = -1.9;
          engineGlow.rotation.x = Math.PI / 2;
          engineGroup.add(engineGlow);
          engineGroup.position.set(i === 0 ? -2.8 : 2.8, 0, -2);
          engines.push(engineGroup);
          this.airship.add(engineGroup);
        }
        this.engines = engines;
        
        // Cannons
        const cannonCount = 3;
        for (let i = 0; i < cannonCount; i++) {
          const cannonGroup = new THREE.Group();
          const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8);
          const barrelMaterial = new THREE.MeshPhongMaterial({
            color: 0x333333,
            metalness: 0.8
          });
          const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
          barrel.rotation.z = Math.PI / 2;
          barrel.position.x = 0.4;
          cannonGroup.add(barrel);
          const baseGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.5);
          const baseMaterial = new THREE.MeshPhongMaterial({
            color: 0x8B4513
          });
          const base = new THREE.Mesh(baseGeometry, baseMaterial);
          cannonGroup.add(base);
          cannonGroup.position.set(2.6, 0.8, -3 + i * 2);
          this.airship.add(cannonGroup);
          const cannonGroup2 = cannonGroup.clone();
          cannonGroup2.rotation.z = Math.PI;
          cannonGroup2.position.set(-2.6, 0.8, -3 + i * 2);
          this.airship.add(cannonGroup2);
        }
        
        // Cabin/quarterdeck
        const cabinGeometry = new THREE.BoxGeometry(3, 1.5, 3);
        const cabinMaterial = new THREE.MeshPhongMaterial({
          color: 0x8B4513,
          flatShading: false
        });
        const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
        cabin.position.set(0, 1.5, -4);
        cabin.castShadow = true;
        const windowGeometry = new THREE.PlaneGeometry(0.4, 0.4);
        const windowMaterial = new THREE.MeshPhongMaterial({
          color: 0x87CEFA,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
        backWindow.position.set(0, 0, -1.55);
        cabin.add(backWindow);
        const sideWindow1 = new THREE.Mesh(windowGeometry, windowMaterial);
        sideWindow1.rotation.y = Math.PI / 2;
        sideWindow1.position.set(1.55, 0, 0);
        cabin.add(sideWindow1);
        const sideWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
        sideWindow2.rotation.y = Math.PI / 2;
        sideWindow2.position.set(-1.55, 0, 0);
        cabin.add(sideWindow2);
        
        // Railings
        this.addRailings();
        
        // Assemble the airship
        this.airship.add(hull, deck, mast, mainSail, frontSail, flagPole, cabin);
        this.engineGlows = engines.map(engine => engine.children[2]);
      }
      
      // Helper method for railings around the ship
      addRailings() {
        const railingMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D });
        const postCount = 10;
        const shipLength = 11;
        const shipWidth = 4.8;
        for (let side = -1; side <= 1; side += 2) {
          for (let i = 0; i < postCount; i++) {
            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8, 6), railingMaterial);
            const z = (i / (postCount - 1)) * shipLength - shipLength / 2;
            post.position.set(side * shipWidth / 2, 1.2, z);
            this.airship.add(post);
            if (i < postCount - 1) {
              const railLength = shipLength / (postCount - 1);
              const rail = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, railLength + 0.05), railingMaterial);
              rail.position.set(side * shipWidth / 2, 1.5, z + railLength / 2);
              this.airship.add(rail);
            }
          }
        }
        for (let side = -1; side <= 1; side += 2) {
          const postCount = 5;
          for (let i = 0; i < postCount; i++) {
            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8, 6), railingMaterial);
            const x = (i / (postCount - 1)) * shipWidth - shipWidth / 2;
            post.position.set(x, 1.2, side * shipLength / 2);
            this.airship.add(post);
            if (i < postCount - 1) {
              const railLength = shipWidth / (postCount - 1);
              const rail = new THREE.Mesh(new THREE.BoxGeometry(railLength + 0.05, 0.05, 0.05), railingMaterial);
              rail.position.set(x + railLength / 2, 1.5, side * shipLength / 2);
              this.airship.add(rail);
            }
          }
        }
      }
      
      // LIDAR-like terrain generation with fog-aware point cloud
      createLIDARTerrain() {
        this.terrain = new THREE.Group();
        this.scene.add(this.terrain);
        const terrainSize = 500;
        const resolution = 50;
        const heightScale = 80;
        const noiseScale = 0.05;
        this.heightMap = this.generateHeightMap(resolution, noiseScale);
        const positions = [];
        const colors = [];
        const pointSize = 1.5;
        for (let x = 0; x < resolution; x++) {
          for (let z = 0; z < resolution; z++) {
            const height = this.heightMap[x][z] * heightScale;
            if (Math.random() > 0.25) continue;
            const worldX = (x / resolution) * terrainSize - terrainSize / 2;
            const worldZ = (z / resolution) * terrainSize - terrainSize / 2;
            positions.push(worldX, height, worldZ);
            if (height < 5) {
              colors.push(0.0, 0.3, 0.8);
            } else if (height < 15) {
              colors.push(0.1, 0.8, 0.2);
            } else if (height < 25) {
              colors.push(0.0, 0.5, 0.0);
            } else if (height < 35) {
              colors.push(0.6, 0.6, 0.6);
            } else if (height < 45) {
              colors.push(0.7, 0.7, 0.7);
            } else if (height < 55) {
              colors.push(0.8, 0.8, 0.8);
            } else {
              colors.push(1.0, 1.0, 1.0);
            }
          }
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        // PointsMaterial with fog enabled
        const material = new THREE.PointsMaterial({
          size: pointSize,
          vertexColors: true,
          sizeAttenuation: true,
          fog: true
        });
        const pointCloud = new THREE.Points(geometry, material);
        this.terrain.add(pointCloud);
        this.camera.far = 2000;
        this.camera.updateProjectionMatrix();
        console.log("Terrain created with", positions.length / 3, "points");
        this.addVegetation(this.heightMap, resolution, terrainSize, heightScale);
      }
      
      // Generate a heightmap using a simplex-like noise algorithm
      generateHeightMap(resolution, noiseScale) {
        const heightMap = [];
        const noise = (x, z) => {
          const nx = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 0.4 +
                     Math.sin(x * 0.6) * Math.cos(z * 0.6) * 0.3 +
                     Math.sin(x * 1.0) * Math.cos(z * 1.0) * 0.2 +
                     Math.sin(x * 1.5) * Math.cos(z * 1.5) * 0.1;
          const nz = Math.cos(x * 0.2) * Math.sin(z * 0.2) * 0.4 +
                     Math.cos(x * 0.4) * Math.sin(z * 0.4) * 0.3 +
                     Math.cos(x * 0.8) * Math.sin(z * 0.8) * 0.2 +
                     Math.cos(x * 1.2) * Math.sin(z * 1.2) * 0.1;
          const random = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
          const randomValue = Math.abs(Math.sin(random)) * 0.2;
          const value = (nx + nz) * 0.5 + randomValue;
          return Math.pow(value, 1.6);
        };
        for (let x = 0; x < resolution; x++) {
          heightMap[x] = [];
          for (let z = 0; z < resolution; z++) {
            const nx = x * noiseScale * 0.5;
            const nz = z * noiseScale * 0.5;
            const value = noise(nx, nz) * 0.4 + noise(nx * 1.5, nz * 1.5) * 0.3 +
                          noise(nx * 2.5, nz * 2.5) * 0.2 + noise(nx * 4.0, nz * 4.0) * 0.1;
            heightMap[x][z] = value;
          }
        }
        return heightMap;
      }
      
      // Add vegetation (trees and bushes) based on the heightmap
      addVegetation(heightMap, resolution, terrainSize, heightScale) {
        const treeCount = 150;
        const bushCount = 250;
        this.addTreePoints(heightMap, resolution, terrainSize, heightScale, treeCount);
        this.addBushPoints(heightMap, resolution, terrainSize, heightScale, bushCount);
      }
      
      // Add trees as clusters of points
      addTreePoints(heightMap, resolution, terrainSize, heightScale, count) {
        const positions = [];
        const colors = [];
        const pointSize = 1.5;
        for (let i = 0; i < count; i++) {
          const gridX = Math.floor(Math.random() * resolution);
          const gridZ = Math.floor(Math.random() * resolution);
          const height = heightMap[gridX][gridZ] * heightScale;
          if (height < 10 || height > 30) continue;
          const worldX = (gridX / resolution) * terrainSize - terrainSize / 2;
          const worldZ = (gridZ / resolution) * terrainSize - terrainSize / 2;
          const treeHeight = 4 + Math.random() * 6;
          const trunkColor = [0.5, 0.3, 0.1];
          const leafColor = [0.0, 0.7, 0.0];
          for (let y = 0; y < treeHeight * 0.7; y += 0.5) {
            positions.push(worldX, height + y, worldZ);
            colors.push(...trunkColor);
          }
          const leafRadius = treeHeight * 0.5;
          for (let y = treeHeight * 0.5; y < treeHeight * 1.2; y += 0.4) {
            const layerRadius = leafRadius * (1 - (y - treeHeight * 0.5) / (treeHeight * 0.7));
            const layerPoints = Math.max(3, Math.floor(10 * layerRadius));
            for (let j = 0; j < layerPoints; j++) {
              const angle = (j / layerPoints) * Math.PI * 2;
              const lx = worldX + Math.cos(angle) * layerRadius * (0.8 + Math.random() * 0.4);
              const lz = worldZ + Math.sin(angle) * layerRadius * (0.8 + Math.random() * 0.4);
              positions.push(lx, height + y, lz);
              colors.push(...leafColor);
            }
          }
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({
          size: pointSize,
          vertexColors: true,
          sizeAttenuation: true,
          fog: true
        });
        const trees = new THREE.Points(geometry, material);
        this.terrain.add(trees);
      }
      
      // Add bushes as clusters of points
      addBushPoints(heightMap, resolution, terrainSize, heightScale, count) {
        const positions = [];
        const colors = [];
        const pointSize = 1.2;
        for (let i = 0; i < count; i++) {
          const gridX = Math.floor(Math.random() * resolution);
          const gridZ = Math.floor(Math.random() * resolution);
          const height = heightMap[gridX][gridZ] * heightScale;
          if (height < 5 || height > 30) continue;
          const worldX = (gridX / resolution) * terrainSize - terrainSize / 2;
          const worldZ = (gridZ / resolution) * terrainSize - terrainSize / 2;
          const bushSize = 1.0 + Math.random() * 1.5;
          let bushColor;
          if (height < 15) {
            bushColor = [0.2, 0.8, 0.2];
          } else if (height < 25) {
            bushColor = [0.0, 0.6, 0.0];
          } else {
            bushColor = [0.7, 0.7, 0.3];
          }
          const bushPoints = 15 + Math.floor(bushSize * 10);
          for (let j = 0; j < bushPoints; j++) {
            const radius = bushSize * (0.5 + Math.random() * 0.5);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = worldX + radius * Math.sin(phi) * Math.cos(theta);
            const y = height + radius * Math.cos(phi) + 0.5;
            const z = worldZ + radius * Math.sin(phi) * Math.sin(theta);
            positions.push(x, y, z);
            colors.push(...bushColor);
          }
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({
          size: pointSize,
          vertexColors: true,
          sizeAttenuation: true,
          fog: true
        });
        const bushes = new THREE.Points(geometry, material);
        this.terrain.add(bushes);
        console.log("Vegetation created with", positions.length / 3, "bush points");
      }
      
      // Create a grass ground layer using the same height map
      createGrassGround() {
        const terrainSize = 500;
        const resolution = 50;
        const groundGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, resolution - 1, resolution - 1);
        groundGeometry.rotateX(-Math.PI / 2);
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          const x = Math.floor((vertices[i] + terrainSize / 2) / terrainSize * resolution);
          const z = Math.floor((vertices[i + 2] + terrainSize / 2) / terrainSize * resolution);
          if (x >= 0 && x < resolution && z >= 0 && z < resolution) {
            vertices[i + 1] = this.heightMap[x][z] * 40;
          }
        }
        groundGeometry.computeVertexNormals();
        const colors = [];
        const positionAttribute = groundGeometry.getAttribute('position');
        for (let i = 0; i < positionAttribute.count; i++) {
          const y = positionAttribute.getY(i);
          let color = new THREE.Color();
          if (y < 5) {
            color.setRGB(0.1, 0.3, 0.7);
          } else if (y < 15) {
            const greenVariation = Math.random() * 0.2 - 0.1;
            color.setRGB(0.1, 0.7 + greenVariation, 0.2);
          } else if (y < 25) {
            color.setRGB(0.0, 0.5, 0.1);
          } else {
            color.setRGB(0.5, 0.4, 0.3);
          }
          colors.push(color.r, color.g, color.b);
        }
        groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x4CAF50,
          roughness: 0.8,
          metalness: 0.0,
          flatShading: false,
          vertexColors: true
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.receiveShadow = true;
        ground.position.y = -0.1;
        this.scene.add(ground);
        console.log("Ground layer created");
      }
      
      // Main animation loop
      animate() {
        requestAnimationFrame(() => this.animate());
        const elapsedTime = this.clock.getElapsedTime();
        this.updateEnemies();
        this.updateLock();
        if (this.engineGlows) {
          this.engineGlows.forEach(glow => {
            const pulsate = Math.sin(elapsedTime * 10) * 0.2 + 0.8;
            glow.scale.set(pulsate, 1, pulsate);
            let intensity = 0.5;
            if (this.keys['w']) intensity = 1.0;
            glow.material.color.setRGB(1.0 * intensity, 0.3 * intensity, 0.1 * intensity);
            glow.material.opacity = 0.7 * intensity + 0.3;
          });
        }
        this.updateClouds();
        this.updateAirship();
        this.updateProjectiles();
        if (this.cannonCooldown > 0) this.cannonCooldown--;
        if (this.crosshair) this.crosshair.style.display = 'block';
        this.canFireCannons = true;
        this.renderer.render(this.scene, this.camera);
      }
      
      // Update cloud positions and animations
      updateClouds() {
        const time = Date.now() * 0.00005;
        this.clouds.children.forEach(cloud => {
          if (cloud.userData.type === 'billboard') {
            const angle = cloud.userData.angle + time * cloud.userData.speed;
            const radius = cloud.userData.radius;
            cloud.position.x = Math.cos(angle) * radius;
            cloud.position.z = Math.sin(angle) * radius;
            cloud.position.y += Math.sin(time + cloud.userData.timeOffset) * 0.05;
            cloud.lookAt(0, cloud.position.y, 0);
          } else if (cloud.userData.type === 'fog') {
            cloud.position.y = cloud.userData.originalY + Math.sin(time + cloud.userData.timeOffset) * 3;
            cloud.children.forEach(particle => {
              const pos = particle.userData.originalPos;
              const speed = particle.userData.speed;
              const offset = particle.userData.offset;
              particle.position.x = pos.x + Math.sin(time * speed + offset) * 2;
              particle.position.y = pos.y + Math.cos(time * speed + offset) * 1;
              particle.position.z = pos.z + Math.sin(time * speed * 0.7 + offset) * 2;
              particle.quaternion.copy(this.camera.quaternion);
            });
          }
        });
      }
      
      // Update airship movement and physics
      updateAirship() {
        if (this.isPlayerDead) return;
        const acceleration = this.enginePower;
        const rotationSpeed = 0.03;
        const windForce = new THREE.Vector3(
          (Math.sin(Date.now() * 0.0003) + Math.cos(Date.now() * 0.0007)) * this.windEffect,
          (Math.sin(Date.now() * 0.0005)) * this.windEffect * 0.5,
          (Math.cos(Date.now() * 0.0006) + Math.sin(Date.now() * 0.0009)) * this.windEffect
        );
        this.velocity.add(windForce);
        const terrainInfo = this.checkTerrainCollision();
        const currentHeight = this.airship.position.y - terrainInfo.groundHeight;
        const minHeight = terrainInfo.groundHeight + this.hardDeckLimit;
        let horizontalMovement = false;
        if (this.keys['w']) {
          const direction = new THREE.Vector3(0, 0, 1);
          direction.applyQuaternion(this.airship.quaternion);
          this.velocity.add(direction.multiplyScalar(acceleration));
          horizontalMovement = true;
        }
        if (this.keys['s']) {
          const direction = new THREE.Vector3(0, 0, -1);
          direction.applyQuaternion(this.airship.quaternion);
          this.velocity.add(direction.multiplyScalar(acceleration * 0.7));
          horizontalMovement = true;
        }
        if (this.keys['q']) {
          const direction = new THREE.Vector3(1, 0, 0);
          direction.applyQuaternion(this.airship.quaternion);
          this.velocity.add(direction.multiplyScalar(acceleration * 0.8));
          horizontalMovement = true;
        }
        if (this.keys['e']) {
          const direction = new THREE.Vector3(-1, 0, 0);
          direction.applyQuaternion(this.airship.quaternion);
          this.velocity.add(direction.multiplyScalar(acceleration * 0.8));
          horizontalMovement = true;
        }
        if (this.antigravActive) {
          if (this.keys[' ']) {
            const newHeight = this.airship.position.y + this.verticalSpeed;
            if (newHeight < this.maxAltitude) {
              this.hoverHeight = Math.min(this.hoverHeight + this.verticalSpeed, this.maxAltitude);
              this.velocity.y += this.verticalSpeed * 0.3;
            }
          } else if (this.keys['shift']) {
            this.hoverHeight = Math.max(this.hoverHeight - this.verticalSpeed, minHeight);
            this.velocity.y -= this.verticalSpeed * 0.3;
          }
          const heightDifference = currentHeight - this.hoverHeight;
          if (Math.abs(heightDifference) > 0.01) {
            const antigravForce = -heightDifference * 0.015;
            this.velocity.y = THREE.MathUtils.lerp(this.velocity.y, this.velocity.y + antigravForce, 0.1);
          } else {
            this.velocity.y *= 0.98;
          }
          this.velocity.y *= this.verticalDampening;
        } else {
          this.velocity.y -= 0.02;
        }
        if (this.airship.position.y < minHeight) {
          this.airship.position.y = minHeight;
          this.velocity.y = Math.max(0, this.velocity.y);
        }
        let turnForce = 0;
        if (this.keys['a']) {
          turnForce = rotationSpeed;
          const targetBankAngle = -this.bankingFactor;
          this.airship.rotation.z = THREE.MathUtils.lerp(this.airship.rotation.z, targetBankAngle, 0.1);
        } else if (this.keys['d']) {
          turnForce = -rotationSpeed;
          const targetBankAngle = this.bankingFactor;
          this.airship.rotation.z = THREE.MathUtils.lerp(this.airship.rotation.z, targetBankAngle, 0.1);
        } else {
          this.airship.rotation.z = THREE.MathUtils.lerp(this.airship.rotation.z, 0, 0.1);
        }
        this.rotation.y = this.rotation.y * this.turnInertia + turnForce * (1 - this.turnInertia);
        const previousPosition = this.airship.position.clone();
        this.airship.position.x += this.velocity.x;
        this.airship.position.y += this.velocity.y;
        this.airship.position.z += this.velocity.z;
        this.airship.rotation.y += this.rotation.y;
        this.velocity.x *= this.lateralDrag;
        this.velocity.z *= this.lateralDrag;
        this.velocity.y *= this.verticalDrag;
        const speed = this.velocity.length();
        const isHovering = speed < 0.1;
        const bobbingAmount = isHovering ? 0.005 : Math.max(0, 0.003 - speed * 0.002);
        this.airship.position.y += Math.sin(Date.now() * 0.001) * bobbingAmount;
        if (terrainInfo.collided) {
          if (!this.collisionOccurred && this.collisionCooldown <= 0) {
            this.playCollisionSound();
            this.collisionOccurred = true;
            this.collisionCooldown = 30;
          }
          this.airship.position.copy(previousPosition);
          this.velocity.multiplyScalar(-0.5);
          this.velocity.y = Math.max(this.velocity.y, 0.2);
          this.airship.rotation.z += (Math.random() - 0.5) * 0.1;
          setTimeout(() => { this.airship.rotation.z = 0; }, 500);
        } else {
          this.collisionOccurred = false;
        }
        this.updateEngineSound(horizontalMovement);
        if (this.cameraMode === 'follow') {
          const cameraOffset = new THREE.Vector3(0, 5, -15);
          cameraOffset.applyQuaternion(this.airship.quaternion);
          this.camera.position.copy(this.airship.position).add(cameraOffset);
          this.camera.lookAt(this.airship.position);
        } else if (this.cameraMode === 'orbit') {
          const horizontalRadius = this.orbitDistance * Math.cos(this.orbitAngleVertical);
          const verticalOffset = this.orbitDistance * Math.sin(this.orbitAngleVertical);
          const cameraPosition = new THREE.Vector3(
            horizontalRadius * Math.sin(this.orbitAngleHorizontal),
            this.orbitHeight + verticalOffset,
            horizontalRadius * Math.cos(this.orbitAngleHorizontal)
          );
          cameraPosition.applyQuaternion(this.airship.quaternion);
          this.camera.position.copy(this.airship.position).add(cameraPosition);
          this.camera.lookAt(this.airship.position);
        } else {
          this.camera.position.set(
            this.airship.position.x,
            this.airship.position.y + 100,
            this.airship.position.z
          );
          this.camera.lookAt(this.airship.position);
        }
      }
      
      // Engine sound update based on thrust
      updateEngineSound(thrustApplied) {
        const targetIntensity = thrustApplied ? 1.0 : 0.3;
        this.engineSoundIntensity = THREE.MathUtils.lerp(this.engineSoundIntensity, targetIntensity, 0.1);
        if (!this.audioContext && !this.engineSoundEnabled) {
          if (this.keys['w'] || this.keys['s'] || this.keys['a'] || this.keys['d'] || this.keys[' '] || this.keys['shift']) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.setupEngineSound();
            this.engineSoundEnabled = true;
          }
        }
        if (this.engineSoundEnabled && this.engineOscillator) {
          const baseFreq = 100 + this.engineSoundIntensity * 50;
          this.engineOscillator.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);
          if (this.engineGainNode) {
            const volume = this.engineSoundIntensity * 0.15;
            this.engineGainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
          }
        }
      }
      
      // Set up continuous engine sound using Web Audio API
      setupEngineSound() {
        if (!this.audioContext) return;
        this.engineOscillator = this.audioContext.createOscillator();
        this.engineGainNode = this.audioContext.createGain();
        this.engineOscillator.type = 'sawtooth';
        this.engineOscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
        const modulator = this.audioContext.createOscillator();
        const modulatorGain = this.audioContext.createGain();
        modulator.type = 'sine';
        modulator.frequency.setValueAtTime(7, this.audioContext.currentTime);
        modulatorGain.gain.setValueAtTime(10, this.audioContext.currentTime);
        modulator.connect(modulatorGain);
        modulatorGain.connect(this.engineOscillator.frequency);
        this.engineGainNode.gain.setValueAtTime(0.05, this.audioContext.currentTime);
        this.engineOscillator.connect(this.engineGainNode);
        this.engineGainNode.connect(this.audioContext.destination);
        this.engineOscillator.start();
        modulator.start();
      }
      
      // Terrain collision detection
      checkTerrainCollision() {
        const terrainSize = 500;
        const resolution = 50;
        const pos = this.airship.position;
        if (pos.x < -terrainSize/2 || pos.x > terrainSize/2 || pos.z < -terrainSize/2 || pos.z > terrainSize/2) {
          return { collided: false, groundHeight: 0 };
        }
        const gridX = Math.floor((pos.x + terrainSize/2) / terrainSize * resolution);
        const gridZ = Math.floor((pos.z + terrainSize/2) / terrainSize * resolution);
        if (gridX < 0 || gridX >= resolution || gridZ < 0 || gridZ >= resolution) {
          return { collided: false, groundHeight: 0 };
        }
        const groundHeight = this.heightMap[gridX][gridZ] * 40;
        const airshipBottom = pos.y - 2.0;
        const collided = airshipBottom < groundHeight;
        return { collided, groundHeight };
      }
      
      // Play a collision sound using Web Audio API
      playCollisionSound() {
        try {
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(30, this.audioContext.currentTime + 0.5);
          gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          oscillator.start();
          oscillator.stop(this.audioContext.currentTime + 0.5);
          this.showCollisionEffect();
        } catch (e) {
          console.log("Audio not supported", e);
        }
      }
      
      // Visual collision effect
      showCollisionEffect() {
        const flash = new THREE.Mesh(
          new THREE.SphereGeometry(3, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 0.7
          })
        );
        flash.position.copy(this.airship.position);
        this.scene.add(flash);
        let opacity = 0.7;
        const fadeOut = setInterval(() => {
          opacity -= 0.05;
          flash.material.opacity = opacity;
          if (opacity <= 0) {
            clearInterval(fadeOut);
            this.scene.remove(flash);
          }
        }, 50);
      }
      
      // Handle window resize
      handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }
      
      // Mouse down event handling
      handleMouseDown(event) {
        if (event.button === 0) {
          this.cursorPosition = { x: event.clientX, y: event.clientY };
          this.fireCannons();
          if (this.cameraMode === 'orbit' && (event.buttons & 2)) {
            this.isMouseDown = true;
            this.lastMouseX = event.clientX;
            this.lastMouseY = event.clientY;
          }
        } else if (event.button === 2) {
          this.isMouseDown = true;
          this.lastMouseX = event.clientX;
          this.lastMouseY = event.clientY;
        }
      }
      
      // Mouse up event handling
      handleMouseUp() {
        this.isMouseDown = false;
      }
      
      // Mouse move event handling for orbiting
      handleMouseMove(event) {
        this.cursorPosition = { x: event.clientX, y: event.clientY };
        if (this.crosshair) {
          this.crosshair.style.left = (event.clientX - 10) + 'px';
          this.crosshair.style.top = (event.clientY - 10) + 'px';
        }
        if (!this.isMouseDown || this.cameraMode !== 'orbit') return;
        const deltaX = event.clientX - this.lastMouseX;
        const deltaY = event.clientY - this.lastMouseY;
        this.orbitAngleHorizontal -= deltaX * this.mouseSensitivity;
        this.orbitAngleVertical = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.orbitAngleVertical + deltaY * this.mouseSensitivity));
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
      }
      
      // Mouse wheel event for zooming in orbit mode
      handleMouseWheel(event) {
        if (this.cameraMode !== 'orbit') return;
        this.orbitDistance = Math.max(5, Math.min(30, this.orbitDistance + event.deltaY * 0.01));
      }
      
      // Firing cannons based on cursor position and camera mode
      fireCannons() {
        if (this.cannonCooldown > 0 || !this.canFireCannons) return;
        const raycaster = new THREE.Raycaster();
        const normalizedPosition = new THREE.Vector2(
          (this.cursorPosition.x / window.innerWidth) * 2 - 1,
          -(this.cursorPosition.y / window.innerHeight) * 2 + 1
        );
        raycaster.setFromCamera(normalizedPosition, this.camera);
        if (this.cameraMode === 'orbit') {
          this.targetPoint.copy(raycaster.ray.direction).multiplyScalar(50).add(this.camera.position);
        } else if (this.cameraMode === 'follow') {
          const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.airship.quaternion);
          this.targetPoint.copy(forward).multiplyScalar(50).add(this.airship.position);
        } else if (this.cameraMode === 'overhead') {
          const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
          const targetRay = new THREE.Ray(this.camera.position, raycaster.ray.direction);
          const targetPoint = new THREE.Vector3();
          targetRay.intersectPlane(groundPlane, targetPoint);
          if (targetPoint.length() > 0) {
            this.targetPoint.copy(targetPoint);
          } else {
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.airship.quaternion);
            this.targetPoint.copy(forward).multiplyScalar(50).add(this.airship.position);
          }
        }
        const shipRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.airship.quaternion);
        const toTarget = new THREE.Vector3().subVectors(this.targetPoint, this.airship.position);
        const rightDot = shipRight.dot(toTarget);
        const shipForward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.airship.quaternion);
        const forwardDot = shipForward.dot(toTarget);
        const cannonPositions = [];
        if (rightDot > 0) {
          cannonPositions.push({ x: 2.6, z: -3 }, { x: 2.6, z: -1 }, { x: 2.6, z: 1 });
        } else {
          cannonPositions.push({ x: -2.6, z: -3 }, { x: -2.6, z: -1 }, { x: -2.6, z: 1 });
        }
        if (forwardDot > 0) {
          cannonPositions.reverse();
        }
        let delay = 0;
        cannonPositions.forEach(pos => {
          setTimeout(() => {
            this.fireCannonAtPosition(pos);
          }, delay);
          delay += 100;
        });
        this.cannonCooldown = this.cannonCooldownTime;
      }
      
      // Fire an individual cannon at a specified position
      fireCannonAtPosition(pos) {
        const projectile = new THREE.Group();
        const cannonball = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 12, 12),
          new THREE.MeshPhongMaterial({
            color: 0x333333,
            emissive: 0xff4400,
            emissiveIntensity: 0.8,
            metalness: 0.7,
            roughness: 0.3
          })
        );
        projectile.add(cannonball);
        const glowCore = new THREE.PointLight(0xff4400, 2, 3);
        projectile.add(glowCore);
        const trailParticles = new THREE.Points(
          new THREE.BufferGeometry(),
          new THREE.PointsMaterial({
            color: 0xff4400,
            size: 0.2,
            transparent: true,
            opacity: 0.6
          })
        );
        const particlePositions = new Float32Array(30 * 3);
        trailParticles.geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        projectile.add(trailParticles);
        const worldPos = new THREE.Vector3(pos.x, 0.8, pos.z);
        worldPos.applyQuaternion(this.airship.quaternion);
        worldPos.add(this.airship.position);
        projectile.position.copy(worldPos);
        const direction = new THREE.Vector3().subVectors(this.targetPoint, worldPos).normalize();
        this.scene.add(projectile);
        this.projectiles.push({
          mesh: projectile,
          velocity: direction.multiplyScalar(4.0),
          timeAlive: 0,
          trailParticles: trailParticles,
          particlePositions: particlePositions
        });
        this.createMuzzleFlash(worldPos);
        this.playCannonSound();
      }
      
      // Muzzle flash effect
      createMuzzleFlash(position) {
        const flash = new THREE.PointLight(0xff4400, 5, 8);
        flash.position.copy(position);
        this.scene.add(flash);
        setTimeout(() => { this.scene.remove(flash); }, 100);
      }
      
      // Simplified cannon sound effect
      playCannonSound() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.2);
      }
      
      // Update projectiles: move and remove old ones
      updateProjectiles() {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
          const proj = this.projectiles[i];
          proj.mesh.position.add(proj.velocity);
          proj.timeAlive += this.clock.getDelta();
          if (proj.timeAlive > 5) {
            this.scene.remove(proj.mesh);
            this.projectiles.splice(i, 1);
          }
        }
      }
      
      // Placeholder: create lock indicator for targeting
      createLockIndicator() {
        // Implementation as needed
      }
      
      // Placeholder: update lock indicator
      updateLock() {
        // Implementation as needed
      }
      
      // Create a crosshair at the center of the screen
      createCrosshair() {
        this.crosshair = document.createElement('div');
        this.crosshair.style.position = 'fixed';
        this.crosshair.style.width = '20px';
        this.crosshair.style.height = '20px';
        this.crosshair.style.top = '50%';
        this.crosshair.style.left = '50%';
        this.crosshair.style.transform = 'translate(-50%, -50%)';
        this.crosshair.style.border = '1px solid red';
        document.body.appendChild(this.crosshair);
      }
      
      // Placeholder: update enemy ships (if any)
      updateEnemies() {
        // Implementation as needed
      }
    }
    
    // Instantiate the game
    new AirshipGame();
  </script>
</body>
</html>
