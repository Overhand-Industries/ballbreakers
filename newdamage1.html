<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- The viewport-fit=cover tells supported browsers to use the full display area -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
  <title>Platformer with Goals, Scoring & Dual-Hand Grab-Throw Shooting</title>
  <style>
    /* ... (your CSS remains unchanged) ... */
  </style>
</head>
<body>
  <!-- Scoreboard and game container elements remain unchanged -->
  <div id="scoreboard">
    <span id="leftScore">0</span> - <span id="rightScore">0</span>
  </div>
  
  <div id="gameboy">
    <div id="screen">
      <div id="parallax"></div>
      <div id="game"></div>
    </div>
    <div id="controls">
      <div id="dpad">
        <button class="up"></button>
        <button class="down"></button>
        <button class="left"></button>
        <button class="right"></button>
        <div id="joystick"></div>
      </div>
      <div id="ab-buttons">
        <button class="A"></button>
        <button class="B"></button>
        <button class="C"></button>
      </div>
    </div>
  </div>

  <!-- Matter.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // Matter.js Modules
    const { Engine, World, Bodies, Body, Constraint, Events, Composites, Composite } = Matter;

    // ***** GLOBAL VARIABLES FOR PLAYER COLLISIONS *****
    // Unique ID counter for players.
    let playerIdCounter = 1;
    // Track last collision time between two players (to avoid multiple triggers).
    let globalPlayerCollisionTimestamps = {};

    // Global Variables & Setup
    const game = document.getElementById("game");
    let engine = Engine.create();
    engine.world.gravity.y = 3.2;
    const world = engine.world;
    let tvs = [];
    let domEntities = [], platforms = [], walls = [], coins = [], bullets = [], enemies = [];
    let leftScore = 0, rightScore = 0;

    // Separate input objects for player one and player two
    let keys1 = {}, keys2 = {};
    let joystickAim1 = { x: 0, y: 0 }, joystickAim2 = { x: 0, y: 0 };
    let walkCycle1 = 0, walkCycle2 = 0;
    let lastTime = Date.now();
    
    // Level dimensions
    const levelWidth = 3000;
    function getViewportHeight() {
      return window.visualViewport ? window.visualViewport.height : window.innerHeight;
    }
    let gameHeight = getViewportHeight();
    let playAreaHeight = getViewportHeight() - 100;
    const groundExtraHeight = 100;
    game.style.width = levelWidth + "px";
    game.style.height = gameHeight + "px";

    // Create ground element
    const groundEl = document.createElement("div");
    groundEl.id = "ground";
    groundEl.style.top = (playAreaHeight - 20) + "px";
    groundEl.style.width = levelWidth + "px";
    groundEl.style.height = groundExtraHeight + "px";
    game.appendChild(groundEl);

    // Helper to create a DOM element for a Matter body
    function createDomElement(body, cls, w, h) {
      const el = document.createElement("div");
      el.className = "entity " + cls;
      el.style.width = w + "px";
      el.style.height = h + "px";
      game.appendChild(el);
      body.domElement = el;
      domEntities.push(body);
    }

    /* --- Platforms / Boulders and Walls creation functions remain unchanged --- */

    // Static boundaries & safety floor
    // Add a label to the ground body so we can later detect collisions.
    const groundBody = Bodies.rectangle(levelWidth / 2, playAreaHeight, levelWidth, 40, { isStatic: true });
    groundBody.label = "ground";  // <<-- NEW: Label ground for collision checks.
    const leftBoundary = Bodies.rectangle(0, playAreaHeight / 2, 40, playAreaHeight, { isStatic: true });
    const rightBoundary = Bodies.rectangle(levelWidth, playAreaHeight / 2, 40, playAreaHeight, { isStatic: true });
    World.add(world, [groundBody, leftBoundary, rightBoundary]);
    const safetyFloorY = playAreaHeight + 50;
    const safetyFloor = Bodies.rectangle(levelWidth / 2, safetyFloorY, levelWidth, 40, { isStatic: true, label: "safetyFloor" });
    World.add(world, safetyFloor);

    // Create Goal Sensors and associated DOM elements (unchanged)
    const goalWidth = 20, goalHeight = 200;
    const leftGoal = Bodies.rectangle(50, playAreaHeight/2, goalWidth, goalHeight, { isStatic: true, isSensor: true, label: "leftGoal" });
    const rightGoal = Bodies.rectangle(levelWidth - 50, playAreaHeight/2, goalWidth, goalHeight, { isStatic: true, isSensor: true, label: "rightGoal" });
    World.add(world, [leftGoal, rightGoal]);
    function createGoalDom(goalBody, cls) {
      const el = document.createElement("div");
      el.className = "goal " + cls;
      el.style.width = goalWidth + "px";
      el.style.height = goalHeight + "px";
      el.style.left = (goalBody.position.x - goalWidth / 2) + "px";
      el.style.top = (goalBody.position.y - goalHeight / 2) + "px";
      game.appendChild(el);
      goalBody.domElement = el;
    }
    createGoalDom(leftGoal, "left");
    createGoalDom(rightGoal, "right");
    // (Goal walls creation remains unchanged.)

    // --- Character Factory (Player) ---
    function createCharacter(x, y) {
      const char = { hp: 100, alive: true, spawn: { x, y }, heldObject: null, isDying: false };
      char.id = playerIdCounter++;  // <<-- NEW: Assign a unique ID for collision tracking.
      char.facing = "right";
      const size = 20;
      const torsoOptions = { friction: 6.0, frictionAir: 0.11, restitution: 0 };
      const defaultOptions = { friction: 0.5, frictionAir: 0.01, restitution: 0 };

      // Create an HP bar element (unchanged)
      const hpContainer = document.createElement("div");
      hpContainer.className = "hp-bar-container";
      const hpBar = document.createElement("div");
      hpBar.className = "hp-bar";
      hpContainer.appendChild(hpBar);
      game.appendChild(hpContainer);
      char.hpContainer = hpContainer;
      char.hpBar = hpBar;

      function addPart(body, cls, w, h) {
        createDomElement(body, cls, w, h);
        body.character = char;
        if (cls.indexOf("head") !== -1) {
          attachTentacleToBody(body, { x: 0, y: size/2 }, 5, 10, 2);
          const eyeLeft = document.createElement("div");
          eyeLeft.className = "eye left";
          const eyeRight = document.createElement("div");
          eyeRight.className = "eye right";
          body.domElement.appendChild(eyeLeft);
          body.domElement.appendChild(eyeRight);
        }
        return body;
      }

      // Create body parts (unchanged)
      const head = Bodies.circle(x, y - 40, size / 2, defaultOptions);
      addPart(head, "player-part head", size, size);
      const torso = Bodies.circle(x, y - 20, size, torsoOptions);
      addPart(torso, "player-part torso", size * 2, size * 2);
      const rightUpperArm = Bodies.circle(x + 30, y - 20, size / 2, defaultOptions);
      addPart(rightUpperArm, "player-part arm", size, size);
      const rightHand = Bodies.circle(x + 30, y, size / 2, defaultOptions);
      addPart(rightHand, "player-part hand", size, size);
      const leftUpperArm = Bodies.circle(x - 30, y - 20, size / 2, defaultOptions);
      addPart(leftUpperArm, "player-part arm", size, size);
      const leftHand = Bodies.circle(x - 30, y, size / 2, defaultOptions);
      addPart(leftHand, "player-part hand", size, size);
      const rightUpperLeg = Bodies.circle(x + 10, y + 10, size / 2, defaultOptions);
      addPart(rightUpperLeg, "player-part leg", size, size);
      const rightFoot = Bodies.circle(x + 10, y + 30, size / 2, defaultOptions);
      addPart(rightFoot, "player-part foot", size, size);
      const leftUpperLeg = Bodies.circle(x - 10, y + 10, size / 2, defaultOptions);
      addPart(leftUpperLeg, "player-part leg", size, size);
      const leftFoot = Bodies.circle(x - 10, y + 30, size / 2, defaultOptions);
      addPart(leftFoot, "player-part foot", size, size);

      World.add(world, [head, torso, rightUpperArm, rightHand, leftUpperArm, leftHand, rightUpperLeg, rightFoot, leftUpperLeg, leftFoot]);

      // Link body parts (unchanged)
      function link(a, b, offA, offB) {
        const con = Constraint.create({
          bodyA: a, pointA: offA, bodyB: b, pointB: offB,
          stiffness: 1, length: 0.1
        });
        World.add(world, con);
      }
      link(head, torso, { x: 0, y: size/2 }, { x: 0, y: -size });
      link(torso, rightUpperArm, { x: size, y: 0 }, { x: 0, y: 0 });
      link(rightUpperArm, rightHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperArm, { x: -size, y: 0 }, { x: 0, y: 0 });
      link(leftUpperArm, leftHand, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, rightUpperLeg, { x: 10, y: size }, { x: 0, y: -size/2 });
      link(rightUpperLeg, rightFoot, { x: 0, y: 0 }, { x: 0, y: -20 });
      link(torso, leftUpperLeg, { x: -10, y: size }, { x: 0, y: -size/2 });
      link(leftUpperLeg, leftFoot, { x: 0, y: 0 }, { x: 0, y: -20 });

      char.head = head; 
      char.torso = torso;
      char.rightUpperArm = rightUpperArm; 
      char.rightHand = rightHand;
      char.leftUpperArm = leftUpperArm; 
      char.leftHand = leftHand;
      char.rightUpperLeg = rightUpperLeg; 
      char.rightFoot = rightFoot;
      char.leftUpperLeg = leftUpperLeg; 
      char.leftFoot = leftFoot;

      return char;
    }
    // Create two players (unchanged)
    let playerChar1 = createCharacter(100, playAreaHeight / 2);
    let playerChar2 = createCharacter(levelWidth - 100, playAreaHeight / 2);

    // --- NEW: Add extra CSS classes for distinct styling (unchanged) ---
    function addPlayerClass(player, className) {
      let parts = [player.head, player.torso, player.rightUpperArm, player.rightHand,
                   player.leftUpperArm, player.leftHand, player.rightUpperLeg, player.rightFoot,
                   player.leftUpperLeg, player.leftFoot];
      parts.forEach(part => {
        if (part.domElement) { part.domElement.classList.add(className); }
      });
    }
    addPlayerClass(playerChar1, "player1");
    addPlayerClass(playerChar2, "player2");

    // --- Enhanced Enemy Implementation (unchanged) ---
    function createEnemy(x, y) {
      let enemy = {
        hp: 50,
        alive: true,
        state: "patrol",
        direction: Math.random() < 0.5 ? -1 : 1
      };
      enemy.body = Bodies.circle(x, y, 20, { 
        friction: 0.5, 
        frictionAir: 0.05, 
        restitution: 0.9,
        label: "enemy",
        isBullet: true
      });
      createDomElement(enemy.body, "enemy", 40, 40);
      World.add(world, enemy.body);

      enemy.update = function() {
        // (Enemy AI remains unchanged)
        const dx1 = playerChar1.torso.position.x - enemy.body.position.x;
        const dy1 = playerChar1.torso.position.y - enemy.body.position.y;
        const dist1 = Math.hypot(dx1, dy1);
        const dx2 = playerChar2.torso.position.x - enemy.body.position.x;
        const dy2 = playerChar2.torso.position.y - enemy.body.position.y;
        const dist2 = Math.hypot(dx2, dy2);
        const target = (dist1 < dist2) ? playerChar1 : playerChar2;
        
        const dx = target.torso.position.x - enemy.body.position.x;
        const dy = target.torso.position.y - enemy.body.position.y;
        const horizontalDistance = Math.abs(dx);
        const verticalDistance = Math.abs(dy);
        const chaseThreshold = 400;
        const verticalThreshold = 50;
        enemy.state = (horizontalDistance < chaseThreshold && verticalDistance < verticalThreshold) ? "chase" : "patrol";
        
        if (enemy.state === "chase") {
          const chaseForce = 0.001;
          const forceDirection = dx > 0 ? 1 : -1;
          Body.applyForce(enemy.body, enemy.body.position, { x: forceDirection * chaseForce, y: 0 });
          if (dy < -20 && Math.abs(enemy.body.velocity.y) < 1) {
            Body.setVelocity(enemy.body, { x: enemy.body.velocity.x, y: -10 });
          }
        } else {
          const patrolForce = 0.0005;
          Body.applyForce(enemy.body, enemy.body.position, { x: enemy.direction * patrolForce, y: 0 });
          if (enemy.body.position.x < 50) { enemy.direction = 1; }
          else if (enemy.body.position.x > levelWidth - 50) { enemy.direction = -1; }
        }
      };
      enemies.push(enemy);
      return enemy;
    }
    createEnemy(levelWidth / 2, playAreaHeight / 2);

    // --- PLAYER GRAB-THROW FUNCTION (Modified) ---
    function playerShoot(player, keys, joystickAim) {
      if (player.heldObject) {
        let obj = player.heldObject;
        let dx = 0, dy = 0;
        const aimMag = Math.hypot(joystickAim.x, joystickAim.y);
        if (aimMag > 0.1) { dx = joystickAim.x; dy = joystickAim.y; }
        else {
          if (keys["ArrowUp"])    dy = -1;
          if (keys["ArrowDown"])  dy =  1;
          if (keys["ArrowLeft"])  dx = -1;
          if (keys["ArrowRight"]) dx =  1;
          if (dx === 0 && dy === 0) dx = (player.facing === "left") ? -1 : 1;
          let mag = Math.hypot(dx, dy);
          dx /= mag; dy /= mag;
        }
        const throwSpeed = 55;
        Body.setVelocity(obj, { x: dx * throwSpeed, y: dy * throwSpeed });
        Body.setAngularVelocity(obj, 0.5);
        obj.collisionFilter.mask = 0xFFFFFFFF;
        player.heldObject = null;

        // <<-- NEW: If the thrown object is an enemy, temporarily reduce friction so it bounces rather than sticking.
        if (obj.label === "enemy") {
          const originalFriction = obj.friction;
          const originalFrictionAir = obj.frictionAir;
          obj.friction = 0.01;
          obj.frictionAir = 0.01;
          setTimeout(() => {
            obj.friction = originalFriction;
            obj.frictionAir = originalFrictionAir;
          }, 1000);
        }
      } else {
        const grabRange = 1000;
        let handPos = (player.facing === "left") ? player.leftHand.position : player.rightHand.position;
        let bodies = Composite.allBodies(world);
        let candidate = null;
        let candidateDist = Infinity;
        for (let i = 0; i < bodies.length; i++) {
          let body = bodies[i];
          if (body.isStatic || body.character || body.label === "bullet" || body.label === "leftGoal" || body.label === "rightGoal") continue;
          let dx = body.position.x - handPos.x;
          let dy = body.position.y - handPos.y;
          let dist = Math.hypot(dx, dy);
          if (dist < grabRange && dist < candidateDist) { candidate = body; candidateDist = dist; }
        }
        if (candidate) {
          player.heldObject = candidate;
          Body.setVelocity(candidate, { x: 0, y: 0 });
          candidate.collisionFilter.mask = 0;
        }
      }
    }
    function updateHeldObject(player) {
      if (player.heldObject) {
        let handPos = (player.facing === "left") ? player.leftHand.position : player.rightHand.position;
        Body.setPosition(player.heldObject, handPos);
      }
    }

    // --- NEW: Collision Handler for Player vs. Player Impacts ---
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if (pair.bodyA.character && pair.bodyB.character && pair.bodyA.character !== pair.bodyB.character) {
          const characterA = pair.bodyA.character;
          const characterB = pair.bodyB.character;
          const now = Date.now();
          const key = [characterA.id, characterB.id].sort().join("-");
          if (globalPlayerCollisionTimestamps[key] && now - globalPlayerCollisionTimestamps[key] < 500) return;
          globalPlayerCollisionTimestamps[key] = now;
          
          const vA = pair.bodyA.velocity;
          const vB = pair.bodyB.velocity;
          const relVel = Math.hypot(vA.x - vB.x, vA.y - vB.y);
          const threshold = 5;  // Impact must exceed this relative velocity.
          if (relVel > threshold) {
            // Damage proportional to excess speed (capped at 10)
            const damage = Math.min((relVel - threshold) * 2, 10);
            characterA.hp -= damage;
            characterB.hp -= damage;
            const forceMagnitude = (relVel - threshold) * 0.005;
            const normal = pair.collision.normal;
            Body.applyForce(pair.bodyA, pair.bodyA.position, { 
              x: -normal.x * forceMagnitude, 
              y: -normal.y * forceMagnitude 
            });
            Body.applyForce(pair.bodyB, pair.bodyB.position, { 
              x: normal.x * forceMagnitude, 
              y: normal.y * forceMagnitude 
            });
          }
        }
      });
    });

    // --- NEW: Collision Handler to Prevent Thrown Enemies from Sticking into the Ground ---
    Events.on(engine, "collisionStart", function(event) {
      event.pairs.forEach(pair => {
        if ((pair.bodyA.label === "enemy" && (pair.bodyB.label === "ground" || pair.bodyB.label === "safetyFloor")) ||
            (pair.bodyB.label === "enemy" && (pair.bodyA.label === "ground" || pair.bodyA.label === "safetyFloor"))) {
          let enemyBody = pair.bodyA.label === "enemy" ? pair.bodyA : pair.bodyB;
          if (Math.hypot(enemyBody.velocity.x, enemyBody.velocity.y) < 0.5) {
            Body.applyForce(enemyBody, enemyBody.position, { x: 0, y: -0.02 });
          }
        }
      });
    });

    // --- (Other functions: meleeAttack, digitalPixelExplosion, coin collection, etc. remain unchanged) ---

    // --- Main Game Loop, Input Handling, and DOM Updates remain unchanged ---
    function update() {
      updateGamepadInput();
      Engine.update(engine, 1000/60);
      // ... (player movement, enemy updates, camera, hp bar updates, etc.)
      updateCamera();
      requestAnimationFrame(update);
    }
    update();

    // --- On-Screen Joystick and Button Mappings remain unchanged ---
    // ...
  </script>
</body>
</html>
